     Everything inside a javascript happens inside an execution context.
     inside execution context memory component and code component are there.(it is also know variable environment and theread of execution)
     Global execution context was created and it is put inside callStack.   
 
--->Even before the execution of a single line, the memory is allocated for every variables and functins

--->when creating exectution context for functions it allocates memory for all parameters also along with other variables and fucntions.

--->When ever we return a statement in fucntion then it checks the value for that statement in local memory and it will return it to the variable
    where in outer exectution context.and also exectution context for that funciton will get deleted.

--->Once javascript done it all works then Main exectution context also get deleted.

--->when ever the javascript runs the global object also will created. that is window in case of browsers. 
    in the global lever this === window
    when ever the execution context is created the this will also created along with execution context.
    [
     When JavaScript code runs in a browser environment, a global object is automatically created for you. In browsers,
     this global object is referred to as window. So, in the global context, this refers to the window object.
     For example, if you were to open the browser console and type this, it would return the window object, like this:
     console.log(this === window);
     This means that any variables or functions declared in the global scope are attached as properties and methods to the window object.

    The value of this in a function execution context is determined by how the function is called. There are four ways to call a function:

    Method call: When a function is called as a method of an object, this refers to that object.
    Direct call: When a function is called directly, this refers to the global object, unless the function is called in strict mode, in which case this is
    undefined.
    Constructor call: When a function is called with the new keyword, this refers to the new object that is being created.
    Arrow function: Arrow functions do not have their own this binding. Instead, they inherit the this binding of the enclosing lexical context.

    EG:
    // Global scope
const person = {
  name: "Alice",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  },
};

// Function execution context
function greet() {
  console.log(`Hello from the greet function!`);
}

// Method call
person.greet(); // "Hello, my name is Alice"

// Direct call
greet(); // "Hello from the greet function!"

// Constructor call
const newPerson = new Person("Bob");
newPerson.greet(); // "Hello, my name is Bob"

// Arrow function
const arrowGreet = () => console.log(`Hello from the arrow function!`);
arrowGreet(); // "Hello from the arrow function!"
Use code with caution. Learn more

]

--->for the function that function code is allocated in the memory allocation phase.

---> javascript is syncrhronous single threaded language.
     single threaded means js can execute one command at a time in a specific order.

--->Hoisting means we can access the variable and functins even before we are initializing it .

--->Scope means where we can access a specific variable and functins in our code 

--->Why callstack?
    The call stack maintains the order of function calls
    When a function is called in JavaScript, it creates an execution context that contains information about the function, its parameters,
    local variables, and the current position in the code.
    The JavaScript engine starts executing the code inside that function. If that function, in turn, calls another function, 
    the new function's plate is added on top of the previous one, creating a stack of function calls.
    When a function finishes executing, it's like removing a plate from the top of the stack, and the program goes back to the previous
    function in the stack to continue its execution.
    The call stack ensures that JavaScript executes functions in the order they were called.

--->Event loop
    it plays a crucial role in handling asynchronous operations and events in a single-threaded environment.
    When your JavaScript code starts executing, it creates the global execution context and forms the execution stack.
    The execution stack is a stack of function calls that keeps track of the order in which functions are called and executed.
    JavaScript maintains an event queue, which is a queue that stores pending events and tasks.
    Events can be user interactions (e.g., click, keypress) or asynchronous operations (e.g., timers, network requests) that have not yet completed.
    The event loop continuously checks the execution stack and the event queue to determine what task to execute next.
    If the execution stack is empty, the event loop looks at the event queue to see if there are any pending events or tasks to process.
    jif there are events or tasks in the queue, the event loop picks the oldest one (first in the queue that finishes the task) and moves it to the execution stack.


     If JavaScript were to wait for each of these tasks to finish before moving on, it would make the entire application slow and unresponsive.
     The event loop helps solve this problem by allowing JavaScript to keep doing other tasks while waiting for these time-consuming operations to complete.

--->Lexical environment is created whenever the the exectution context is created.
    Lexical environment is the local memory + the referece to the Lexical environment of the parent
    parent means where actually that code present.
    this whole chain of Lexical environment is called scope chain  

--->let and const also allocating memmory (that is what Hoisting).but they are stored in different memory space than global and  
    we cant access this memeory space before we put values in them . The time where we are assigning values to that variable is temporary dead Zone.

--->Shadowing: Now, when a variable is declared in a certain scope having the same name defined on its outer scope and when we call the variable from the inner scope,
   the value assigned to the variable in the inner scope is the value that will be stored in the variable in the memory space. This is known as Shadowing or Variable Shadowing. 
   In JavaScript, the introduction of let and const in ECMAScript 6 along with block scoping allows variable shadowing.
   we can shadow var variable by let variable but cannot do the opposite. 
   but we cant shadow let variable by var variable and it is called illegal shadowing.
        // Outer Scope
        const x = 10;

        function outerFunction() {
        const y = 20;

        function innerFunction() {
            const x = 5; // Inner variable "x" shadows the outer variable "x"
            console.log(x); // Output: 5 (Value of the inner "x" variable)
            console.log(y); // Output: 20 (Accessing the "y" variable from the outer scope)
        }

        innerFunction();
        console.log(x); // Output: 10 (Accessing the "x" variable from the outer scope)
        }

        outerFunction();
        console.log(x); // Output: 10 (Accessing the "x" variable from the outermost scope)


--->let and const will be in block scope when we write let and const inside {}.(inside block like if condition).
    but var will be in global scope if we write inside {}.

--->function along with its Lexical scope is bundled together to form a closure.

    function makeFunc() {
        const name = "Mozilla";
        function displayName() {
            console.log(name);
        }
        return displayName;
    }

    const myFunc = makeFunc();
    myFunc();
   Here it afer the makeFunc get deleted from the global exectution context the myFunc variable still rememebers it lexical scope.

--->First-Class Function: A programming language is said to have First-class functions if functions in that language are treated 
   like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function.
   JavaScript treat function as a first-class-citizens. This means that functions are simply a value and are just another type of object.

--->JavaScript is single threaded and synchronous

--->Synchronous: In synchronous programming, tasks are executed one after the other, in a sequential order. Each task must complete before going to the next task.
                 Synchronous refers to the nature of tasks and how they are handled in a program.That means the nature that it executes in top to bottom order one by one.

--->Asynchronous :The program does not wait for the completion of an particular task and continues executing other code.
                   This nature is called Asynchronous.

--->Single threaded :Ont task will perform at a time. line by line exectution.

--->Multi threaded : multiple task at a time. it wont wait for a particular task to complete.instead it will execute the next line of code.

--->Blocking refers to operations that block further execution until that operation finishes
    
--->non-blocking refers to code that doesn't block execution.

--->Why callback
    we know that javascript is synchronous. That means code will execute line by line. so if a large operation is want to perform then it will wait for that 
    particular line of code to complete. so this will affect the efficient and takes time. so using callback we are setting this Asynchronous. that means it wont wait 
    for the particular code .it will execute the next line of code.
--->what is callback

    a callback is a function that is passed as an argument to another function and is intended to be executed at a later time or under specific conditions. Callbacks are commonly used in
    asynchronous programming to handle the results of asynchronous operations, such as fetching data from a server, reading files, or responding to user input.

--->The main difference between Primitive and non-primitive data types is that Non-primitive data types are mutable, meaning that their values can be changed after they are created. 
    And Primitive data types are immutable, meaning that their values cannot be changed once they are created.

    Mutable objects are objects whose state (i.e., the values of their properties) can be modified after they are created.
     When you change a mutable object, you are typically modifying the same object in memory. Common examples of mutable objects include lists 
     (arrays), dictionaries (objects with key-value pairs), and custom objects.
    et mutableArray = [1, 2, 3];
    mutableArray.push(4); // Modifying the array
    console.log(mutableArray); // Output: [1, 2, 3, 4]

    Immutable objects, on the other hand, are objects whose state cannot be changed once they are created. When you want to modify an immutable object,
     you create a new object with the desired changes instead of modifying the original object. Examples of immutable objects include strings, numbers,
     and frozen objects in JavaScript.
     let immutableString = "Hello";
    let newString = immutableString + ", World!"; // Creating a new string
    console.log(immutableString); // Output: "Hello"
    console.log(newString); // Output: "Hello, World!"

--->Keyword
   a keyword is a reserved word that has a specific meaning and purpose in the language's syntax. 

--->In programming, an identifier is a name used to identify a variable, function, class, object, or any other entity in the code.

--->
Optional chaining is a feature introduced in JavaScript (starting from ECMAScript 2020, also known as ES11) that provides a convenient way to access
 nested properties of an object when the properties may be undefined or null.
const person = {
  name: 'Alice',
  address: {
    city: 'New York',
    zipCode: 12345
  }
};

// Using optional chaining to access nested property
const city = person.address?.city;
 If the object is null or undefined, the expression will short-circuit, and the result will be undefined, without throwing an error.

---> json.stringify() This method is used to convert a JavaScript object (or an array) into a JSON string.
     json.parse() -this method is used to convert a JSON string back into a JavaScript object (or array).

--->Memoization is an optimization technique used in computer programming, including JavaScript, to improve the performance of functions by caching the
 results of expensive function calls. The primary goal of memoization is to avoid redundant computations and reduce the overall processing time by storing 
 previously computed results and returning them directly when the same inputs are encountered again.

In JavaScript, functions can be computationally expensive, especially if they involve complex calculations or repetitive operations. Memoization 
allows you to trade off memory usage for improved execution speed, particularly for functions that are called with the same arguments repeatedly.

The memoization process involves creating a cache (usually an object or a Map) to store the function's input and its corresponding output. When the 
function is called with specific inputs, the memoization system first checks if the result for those inputs already exists in the cache. If it does,
 the cached result is returned directly without recomputing the function. If the result is not in the cache, the function is executed, and the result
  is stored in the cache for future use.

  --->IIFE stands for Immediately Invoked Function Expression. It is a JavaScript function that is defined and executed immediately after its creation. 
        (function() {
        // This code is wrapped in an IIFE and is executed immediately
        var message = "Hello, IIFE!";
        console.log(message);
        })();

         IIFE functions are often used to encapsulate code and create private scopes for variables and functions.
        This helps prevent naming conflicts and keeps variables from polluting the global scope.
        
---> Type casting, also known as type conversion, is the process of converting a value from one data type to another.


--->Higher-order functions are functions in programming languages that can take other functions as arguments, return functions as results, or both.

    .map
    .reduce 
    .filter

--->With call(), an object can use a method belonging to another object.


callback

In JavaScript, a callback function is a function that is passed as an argument to another function and is intended to be executed at a later point in time.
The function receiving the callback can "call back" or execute the provided function once it has completed its task or when a certain event occurs.

Asynchronous operations, such as reading from a file, making network requests, or handling user input, often take time to complete. Instead of waiting
for these operations to finish, JavaScript can continue executing other tasks while keeping track of the callback function. 


A Promise can have three possible states:

Pending: The initial state when the Promise is created and the asynchronous operation is still in progress.

Fulfilled (Resolved): The state when the asynchronous operation is successfully completed, and the Promise has a resulting value. This is also known as "resolved."

Rejected: The state when the asynchronous operation encounters an error or fails to produce the expected result.

Promise.all() is a method in JavaScript that takes an array of Promises as input and returns a new Promise. This new Promise is fulfilled
 with an array containing the resolved values of all the input Promises, in the same order as the original array of Promises. If any of the input
  Promises is rejected, the Promise.all() method immediately rejects with the reason of that rejected Promise.

The syntax for using Promise.all() is as follows: