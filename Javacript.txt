----------------------------------------------

     Everything inside a javascript happens inside an execution context.
     inside execution context memory component and code component are there.(it is also know variable environment and theread of execution)
     Global execution context was created and it is put inside callStack.   
 
--->Even before the execution of a single line, the memory is allocated for every variables and functins

--->when creating exectution context for functions it allocates memory for all parameters also along with other variables and fucntions.

--->When ever we return a statement in fucntion then it checks the value for that statement in local memory and it will return it to the variable
    where in outer exectution context.and also exectution context for that funciton will get deleted.

--->Once javascript done it all works then Main exectution context also get deleted.

----------------------------------------------

--->

    when ever the javascript runs the global object also will created. that is window in case of browsers. 
    in the global lever this === window
    when ever the execution context is created the this will also created along with execution context.
    [
     When JavaScript code runs in a browser environment, a global object is automatically created for you. In browsers,
     this global object is referred to as window. So, in the global context, this refers to the window object.
     For example, if you were to open the browser console and type this, it would return the window object, like this:
     console.log(this === window);
     This means that any variables or functions declared in the global scope are attached as properties and methods to the window object.

    The value of this in a function execution context is determined by how the function is called. There are four ways to call a function:

    Method call: When a function is called as a method of an object, this refers to that object.
    Direct call: When a function is called directly, this refers to the global object, unless the function is called in strict mode, in which case this is
    undefined.
    Constructor call: When a function is called with the new keyword, this refers to the new object that is being created.
    Arrow function: Arrow functions do not have their own this binding. Instead, they inherit the this binding of the enclosing lexical context.
    EG:
    // Global scope
const person = {
  name: "Alice",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  },
};

// Function execution context
function greet() {
  console.log(`Hello from the greet function!`);
}

// Method call
person.greet(); // "Hello, my name is Alice"

// Direct call
greet(); // "Hello from the greet function!"

// Constructor call
const newPerson = new Person("Bob");
newPerson.greet(); // "Hello, my name is Bob"

// Arrow function
const arrowGreet = () => console.log(`Hello from the arrow function!`);
arrowGreet(); // "Hello from the arrow function!"
Use code with caution. Learn more

]

----------------------------------------------

--->for the function that function code is allocated in the memory allocation phase.

---> javascript is syncrhronous single threaded language.
     single threaded means js can execute one command at a time in a specific order.


----------------------------------------------

--->Hoisting means we can access the variable and functins even before we are initializing it .

--->Scope means where we can access a specific variable and functins in our code 

----------------------------------------------

--->Why callstack?
    The call stack maintains the order of function calls
    When a function is called in JavaScript, it creates an execution context that contains information about the function, its parameters,
    local variables, and the current position in the code.
    The JavaScript engine starts executing the code inside that function. If that function, in turn, calls another function, 
    the new function's plate is added on top of the previous one, creating a stack of function calls.
    When a function finishes executing, it's like removing a plate from the top of the stack, and the program goes back to the previous
    function in the stack to continue its execution.
    The call stack ensures that JavaScript executes functions in the order they were called.

--->Event loop
    it plays a crucial role in handling asynchronous operations and events in a single-threaded environment.
    When your JavaScript code starts executing, it creates the global execution context and forms the execution stack.
    The execution stack is a stack of function calls that keeps track of the order in which functions are called and executed.
    JavaScript maintains an event queue, which is a queue that stores pending events and tasks.
    Events can be user interactions (e.g., click, keypress) or asynchronous operations (e.g., timers, network requests) that have not yet completed.
    The event loop continuously checks the execution stack and the event queue to determine what task to execute next.
    If the execution stack is empty, the event loop looks at the event queue to see if there are any pending events or tasks to process.
    jif there are events or tasks in the queue, the event loop picks the oldest one (first in the queue that finishes the task) and moves it to the execution stack.


     If JavaScript were to wait for each of these tasks to finish before moving on, it would make the entire application slow and unresponsive.
     The event loop helps solve this problem by allowing JavaScript to keep doing other tasks while waiting for these time-consuming operations to complete.

--->Lexical environment is created whenever the the exectution context is created.
    Lexical environment is the local memory + the referece to the Lexical environment of the parent
    parent means where actually that code present.
    this whole chain of Lexical environment is called scope chain  

--->let and const also allocating memmory (that is what Hoisting).but they are stored in different memory space than global and  
    we cant access this memeory space before we put values in them . The time where we are assigning values to that variable is temporary dead Zone.
    
    in the let and const also happening the Hoisting.but in if we trying to accss them even before we are initializing it , it will give a reference error. because
    it is not allocating memmory in global space. instead a script is there and there it is allcoating memmory. 
    so the time taking to  which we initializing the value to that variable is called tdz.

--->Shadowing: Now, when a variable is declared in a certain scope having the same name defined on its outer scope and when we call the variable from the inner scope,
   the value assigned to the variable in the inner scope is the value that will be stored in the variable in the memory space. This is known as Shadowing or Variable Shadowing. 
   In JavaScript, the introduction of let and const in ECMAScript 6 along with block scoping allows variable shadowing.
   we can shadow var variable by let variable but cannot do the opposite. 
   but we cant shadow let variable by var variable and it is called illegal shadowing.
        // Outer Scope
        const x = 10;

        function outerFunction() {
        const y = 20;

        function innerFunction() {
            const x = 5; // Inner variable "x" shadows the outer variable "x"
            console.log(x); // Output: 5 (Value of the inner "x" variable)
            console.log(y); // Output: 20 (Accessing the "y" variable from the outer scope)
        }

        innerFunction();
        console.log(x); // Output: 10 (Accessing the "x" variable from the outer scope)
        }

        outerFunction();
        console.log(x); // Output: 10 (Accessing the "x" variable from the outermost scope)
    
    --->illegal shadowing
        This happens because let and var both technically have the same scope meaning that the variable name fruit already exists there.
        The variable declared with the var in the block scope is not scoped and is accessible from the outside.
         
         funciton a(){
            let b=10;
            {
                var b=20;
                console.local(b)
            }
         }
         this is the example of illegal shadowing

--->let and const will be in block scope when we write let and const inside {}.(inside block like if condition).
    but var will be in global scope if we write inside {}.

--->function along with its Lexical scope is bundled together to form a closure.
     a funciton bind with the variables of its outer funciton
    function makeFunc() {
        const name = "Mozilla";
        function displayName(){
            console.log(name);
        }
        return displayName;
    }
    const myFunc = makeFunc();
    myFunc();
   Here it afer the makeFunc get deleted from the global exectution context the myFunc variable still rememebers it lexical scope.

--->First-Class Function: A programming language is said to have First-class functions if functions in that language are treated 
   like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function.
   JavaScript treat function as a first-class-citizens. This means that functions are simply a value and are just another type of object.



--->The main difference between Primitive and non-primitive data types is that Non-primitive data types are mutable, meaning that their values can be changed after they are created. 
    And Primitive data types are immutable, meaning that their values cannot be changed once they are created.

    Mutable objects are objects whose state (i.e., the values of their properties) can be modified after they are created.
     When you change a mutable object, you are typically modifying the same object in memory. Common examples of mutable objects include lists 
     (arrays), dictionaries (objects with key-value pairs), and custom objects.
    et mutableArray = [1, 2, 3];
    mutableArray.push(4); // Modifying the array
    console.log(mutableArray); // Output: [1, 2, 3, 4]

    Immutable objects, on the other hand, are objects whose state cannot be changed once they are created. When you want to modify an immutable object,
    you create a new object with the desired changes instead of modifying the original object. Examples of immutable objects include strings, numbers,
    and frozen objects in JavaScript.
    let immutableString = "Hello";
    let newString = immutableString + ", World!"; // Creating a new string
    console.log(immutableString); // Output: "Hello"
    console.log(newString); // Output: "Hello, World!"
    Immutable: The original string "Hello" remains unchanged. If you had another reference to the original string, it would still contain "Hello".
    so here referece only changing
    Reassignment: You've simply reassigned the variable immutableString to point to a different string ("Kiran").
    This is different from modifying the original string. Strings in JavaScript are immutable to protect their integrity, ensuring that their values
    cannot be accidentally or intentionally altered once created.




--->Keyword
   a keyword is a reserved word that has a specific meaning and purpose in the language's syntax. 

--->In programming, an identifier is a name used to identify a variable, function, class, object, or any other entity in the code.

--->
Optional chaining is a feature introduced in JavaScript (starting from ECMAScript 2020, also known as ES11) that provides a convenient way to access
 nested properties of an object when the properties may be undefined or null.
const person = {
  name: 'Alice',
  address: {
    city: 'New York',
    zipCode: 12345
  }
};

// Using optional chaining to access nested property
const city = person.address?.city;
 If the object is null or undefined, the expression will short-circuit, and the result will be undefined, without throwing an error.

---> json.stringify() This method is used to convert a JavaScript object (or an array) into a JSON string.
     json.parse() -this method is used to convert a JSON string back into a JavaScript object (or array).

--->Memoization is an optimization technique used in computer programming, including JavaScript, to improve the performance of functions by caching the
 results of expensive function calls. The primary goal of memoization is to avoid redundant computations and reduce the overall processing time by storing 
 previously computed results and returning them directly when the same inputs are encountered again.

In JavaScript, functions can be computationally expensive, especially if they involve complex calculations or repetitive operations. Memoization 
allows you to trade off memory usage for improved execution speed, particularly for functions that are called with the same arguments repeatedly.

The memoization process involves creating a cache (usually an object or a Map) to store the function's input and its corresponding output. When the 
function is called with specific inputs, the memoization system first checks if the result for those inputs already exists in the cache. If it does,
 the cached result is returned directly without recomputing the function. If the result is not in the cache, the function is executed, and the result
  is stored in the cache for future use.

  --->IIFE stands for Immediately Invoked Function Expression. It is a JavaScript function that is defined and executed immediately after its creation. 
        (function() {
        // This code is wrapped in an IIFE and is executed immediately
        var message = "Hello, IIFE!";
        console.log(message);
        })();

         IIFE functions are often used to encapsulate code and create private scopes for variables and functions.
        This helps prevent naming conflicts and keeps variables from polluting the global scope.

---> Type casting, also known as type conversion, is the process of converting a value from one data type to another.

--->Higher-order functions are functions in programming languages that can take other functions as arguments, return functions as results, or both.

    .map
    .reduce 
    .filter
    Higher-order functions are a fundamental concept in JavaScript and functional programming. A higher-order function 
    is a function that either takes one or more functions as arguments (callbacks) or returns a function as its result.
     In other words, it treats functions as first-class citizens.

--->With call(), an object can use a method belonging to another object.

-------------------------------------------------------------------------------
callback

--->JavaScript is single threaded and synchronous

--->Synchronous: In synchronous programming, tasks are executed one after the other, in a sequential order. Each task must complete before going to the next task.
                 Synchronous refers to the nature of tasks and how they are handled in a program.That means the nature that it executes in top to bottom order one by one.

--->Asynchronous :The program does not wait for the completion of an particular task and continues executing other code.
                   This nature is called Asynchronous.

--->Single threaded :Ont task will perform at a time. line by line exectution.

--->Multi threaded : multiple task at a time. it wont wait for a particular task to complete.instead it will execute the next line of code.

--->Blocking refers to operations that block further execution until that operation finishes
    
--->non-blocking refers to code that doesn't block execution.

--->Why callback
    we know that javascript is synchronous. That means code will execute line by line. so if a large operation is want to perform then it will wait for that 
    particular line of code to complete. so this will affect the efficient and takes time. so using callback we are setting this Asynchronous. that means it wont wait 
    for the particular code .it will execute the next line of code.
    
--->what is callback

    a callback is a function that is passed as an argument to another function and is intended to be executed at a later time or under specific conditions. Callbacks are commonly used in
    asynchronous programming to handle the results of asynchronous operations, such as fetching data from a server, reading files, or responding to user input.

    eg:function doSomething(callback) {
  console.log("Doing something...");
  // Simulate a time-consuming task
  setTimeout(function() {
        console.log("Task is done!");
        callback(); // Call the callback function
      }, 2000);
    }

    function callbackFunction() {
      console.log("Callback function executed.");
    }

    doSomething(callbackFunction);

In JavaScript, a callback function is a function that is passed as an argument to another function and is intended to be executed at a later point in time.
The function receiving the callback can "call back" or execute the provided function once it has completed its task or when a certain event occurs.


--->event loop 
    the event loop constantly checks if the call stack is empty. If it is, it takes the first task from the task queue (if there's any) and pushes it onto the call stack. This means that the next asynchronous task is processed when the call stack is empty.
    Asynchronous operations, such as reading from a file, making network requests, or handling user input, often take time to complete. Instead of waiting
    for these operations to finish, JavaScript can continue executing other tasks while keeping track of the callback function. 


---->Callback hell

     funciton getData1(callback){
       settimeout(()=>{
           callback() 

       })
     }

     funciton getData2(callback){
      setTimeout(()=>{
           callback() 

      })
     }

    funciton getData3(callback){
      setTimeout(()=>{
            callback() 

      })
    }

     getData1((value)=>{
        console.log(value)
        getData2((val2)=>{
           console.log(val2+value)
           getData3((val3) =>{
            console.log(val2+val3+value)
           })
        })
     })
A Promise can have three possible states:

Pending: The initial state when the Promise is created and the asynchronous operation is still in progress.

Fulfilled (Resolved): The state when the asynchronous operation is successfully completed, and the Promise has a resulting value. This is also known as "resolved."

Rejected: The state when the asynchronous operation encounters an error or fails to produce the expected result.

Promise.all() is a method in JavaScript that takes an array of Promises as input and returns a new Promise. This new Promise is fulfilled
with an array containing the resolved values of all the input Promises, in the same order as the original array of Promises. If any of the input
Promises is rejected, the Promise.all() method immediately rejects with the reason of that rejected Promise.

consider we have multiple apis and we want to resolve it together. then it we will use this promise.all()
Promise.all: You use Promise.all to group these promises together. It takes an array of promises as input.

Wait for All: Promise.all works in the background, and it waits for all the promises in the array to complete. It doesn't matter which one finishes first; 
it waits for all of them.

Resolve Together: Once all the promises are resolved (meaning they've completed successfully), Promise.all itself resolves. It gives you an array of the 
results from each promise in the same order as you provided them.

Continue: Now that you have all the results, you can proceed with the next steps in your code.

The syntax for using Promise.all() is as follows:

eg:
   const promise1 = new Promise((resolve,reject)=>{
      resolve("jithin")
   })
   const promise2 = new Promise((resolve,reject)=>{
      resolve("jinto")
   })

   const promiseAll = Promise.all([promise1,promise2])
   promiseAll.then((res)=>{
    console.log(res)
   })

promise.allsettled()

Promise.allSettled is a JavaScript method that helps you work with multiple promises, but unlike Promise.all, 
it doesn't care if some of them fail or are rejected. It gives you information about all the promises, whether they succeed or fail.
 You use the Promise.allSettled method and pass an array of these promises as input.

Wait for All to Settle: Promise.allSettled works in the background, waiting for all the promises to settle. "Settling" means that a promise can either succeed 
(resolve) or fail (reject).

Once all the promises have settled (either resolved or rejected), Promise.allSettled itself resolves with an array of objects
. Each object represents the outcome of one promise. These objects have two properties:

status: Indicates whether the promise was fulfilled (resolved) or rejected.
value or reason: Depending on whether the promise was fulfilled or rejected, this property contains the result or the reason for rejection.

 const promise1 = new Promise((resolve,reject)=>{
      resolve("jithin")
   })
   const promise2 = new Promise((resolve,reject)=>{
      reject("jinto")
   })

   const promiseAll = Promise.all([promise1,promise2])
   promiseAll.then((res)=>{
    console.log(res)
   })

   results : [{status:fulfilled , "jithin" },
               {status:rejected , reason:"Api failed"}]
              
   
Promise.any()

   const promise1 = new Promise((resolve,reject)=>{
      resolve("jithin")
   })
   const promise2 = new Promise((resolve,reject)=>{
      reject("jinto")
   })

   const promiseAll = Promise.any([promise1,promise2])
   promiseAll.then((res)=>{
    console.log(res)
   })

   this returns a single promise after success.if everything get failed then it will show that "all promises were rejected"
   if the first one is rejected and second one is resolved then it will show the second resolved promise 

Promise.race()

const promise1 = new Promise((resolve,reject)=>{
      resolve("jithin")
   })
   const promise2 = new Promise((resolve,reject)=>{
      reject("Api error")
   })

   const promiseAll = Promise.race([promise1,promise2])
   promiseAll.then((res)=>{
    console.log(res)
   })

   what ever the result of the first promise finished it will show that one. if it is resolved then it shows the resolved promise.
   if it is rejected then it shows the rejected one. 


--->"Promisify" is a term used in JavaScript to describe the process of converting a function that uses callbacks into a function that returns a Promise. 

-------------------------------------------------------------------------------


--->call()->we can borrow funcitons from other objects and use it with the data of some other object. so inside the call() we have to pass what the this 
(this of that funciton) pointing to. 
Call is a function that helps you change the context of the invoking function. In layperson's terms, it helps you replace the value of this(keyword) inside
 a function with whatever value you want.
why call() method using.? so we dont need to write the funciton again and again . we will change the this only.  

eg:
   let name:{
      firstName:"jithin"
      lastName:"Chacko"
   }
   let name2 = {
      firstName:"Jinto",
      lastName:"Ps"
   }

   funciton Person(){
      return this.firstName + " " + this.lastName
   }

   const finalName = Person.call(name2)

   Apply()---> almost same . but difference is in passing the argument .

   eg:
   let name:{
      firstName:"jithin"
      lastName:"Chacko"
   }
   let name2 = {
      firstName:"Jinto",
      lastName:"Ps"
   }

   funciton Person(homeTown,place) {
      return this.firstName + " " + this.lastName + " " +homeTown + " " + place
   }

   const finalName = Person.apply(name2,["kannur","Naduvil"])

   but in call method we will pass the argument induvidually.
   
   bind()---> So in call and apply we are invoking the funciton directly.but bind method doesnot directly invoking the function. instead it gives the 
              copy of exactly same method.which can be Invoked later 

              eg: const res = Person.bind(name) 
                  res()
                  here it create a copy of Person funciton and bind with the name object and return the funciton which can be call late

----------------------------------------------

---->currying
     Currying is a technique used in JavaScript (and in functional programming in general) to transform a function that takes multiple
     arguments into a series of functions, each taking one argument. This makes it easier to work with functions that need to be partially
     applied or composed with other functions.

     funciton multiply(x){
        return funciton y(y){
            console.log(x*y)
        }
     }
     const res  = multiply(3)
     res(3)

----------------------------------------------

--->ternary operator
    ternary operator is a conditional operator.
    condition ? expressionIfTrue : expressionIfFalse

----------------------------------------------

--->Nullish Coalescing Operator (??) 
    It's often used in cases where you want to provide a default value if a variable is null or undefined,
    const someValue = null; // or undefined or any other potentially falsy value
    const result = someValue ?? defaultValue;

----------------------------------------------

--->spread Operator 
    In summary, the spread operator is used for spreading or unpacking values, while the rest operator is used for collecting values
     into arrays or variables. 
    https://chat.openai.com/c/7588db26-a174-41f0-97a1-ddf082f389ad

----------------------------------------------

--->rest operator
    The rest operator is used to collect multiple function arguments into a single array or to collect the remaining elements
    of an iterable (like an array) into a single variable.
    // Collecting function arguments into an array
    function sum(...args) {
    return args.reduce((total, num) => total + num, 0);
    }

    const result = sum(1, 2, 3, 4); // args is [1, 2, 3, 4]

    // Collecting remaining array elements into a variable
    const [first, second, ...rest] = [1, 2, 3, 4, 5];
    // first = 1, second = 2, rest = [3, 4, 5]

----------------------------------------------

--->Shallow copy
     (array1 and array2) that reference the same array in memory. 
     This means that changes made to the nested objects or arrays inside the shallow copy will also affect the original data and vice versa.
     const originalArray = [1, 2, [3, 4]];
    // Shallow copy using the spread operator
    const shallowCopy = [...originalArray];
    shallowCopy[2][0] = 99;
    console.log(originalArray); // Output: [1, 2, [99, 4]]

----------------------------------------------

---->Set Creating a Set
    const uniqueNumbers = new Set();

    // Adding elements to the Set
    uniqueNumbers.add(1);
    uniqueNumbers.add(2);
    uniqueNumbers.add(3);
    uniqueNumbers.add(2); // Duplicate value, won't be added

    // Checking the size of the Set
    console.log(uniqueNumbers.size); // Output: 3

    // Checking if an element exists in the Set
    console.log(uniqueNumbers.has(2)); // Output: true

    // Removing an element from the Set
    uniqueNumbers.delete(2);

    // Iterating through the Set
    for (const number of uniqueNumbers) {
    console.log(number);
    }
----------------------------------------------

---->Map 
    A Map is a collection of key-value pairs where each key is associated with a value. Unlike objects, Map keys can be of any data type,
     including objects and functions.
     You can use a Map when you need to store data with an associated key or when you want to preserve the order of insertion.that means,
     Keys are stored in the order in which they were added, making it useful for scenarios where the order of items matters.
     // Creating a Map
    const personMap = new Map();

    // Adding key-value pairs to the Map
    personMap.set("name", "John");
    personMap.set("age", 30);
    personMap.set("isStudent", false);

    // Retrieving values from the Map
    console.log(personMap.get("name")); // Output: "John"

    // Checking if a key exists in the Map
    console.log(personMap.has("age")); // Output: true

    // Deleting a key-value pair from the Map
    personMap.delete("isStudent");

    // Iterating through the Map
    for (const [key, value] of personMap) {
    console.log(`${key}: ${value}`);
    }
----------------------------------------------

---->difference of map and object
     
     .In an Object, keys are always strings or symbols.
     .In a Map, keys can be of any data type, including objects, functions, and primitive values. 

     .The order of keys in an Object is not guaranteed to be preserved. 
     .in map it is preserved

----------------------------------------------

--->Diff between null and undefined
    let myVariable = null; // Initializing myVariable as empty
    You can explicitly assign null to a variable to indicate that it has no value or to reset its value to an empty state.
    on the other hand, is a value that you can explicitly assign to a variable to indicate that it has no value or is empty.

    undefined is a primitive value that is automatically assigned to a variable that has been declared but hasn't been assigned any value.
----------------------------------------------

--->Weakset
    In JavaScript, both WeakSet and WeakMap are specialized collections that allow you to store and manage objects 
    Once the objects are no longer referenced in the code (set to null in this case), they can be garbage collected, and the WeakSet
    will automatically remove them because the references to them are weak.

    A WeakSet can only store objects as values. Primitive values (e.g., numbers, strings) are not allowed.
----------------------------------------------
 
--->WeakMap
    Key-Value Pairs: A WeakMap stores key-value pairs, where the keys are objects and the values can be of any data type
    (including objects, functions, and primitive values).
    Uniqueness: Each key in a WeakMap must be unique, similar to how keys work in regular maps.
    Both the keys and values in a WeakMap are stored as weak references. If there are no other references to a key 
    (or its associated value), both the key and the value can be garbage collected.
    Iteration: Unlike WeakSet, WeakMap provides methods to iterate through its key-value pairs (keys(), values(),
    and entries()). You can use these methods to work with the data stored in the map.
    // Creating a WeakMap
        const weakMap = new WeakMap();

        // Creating objects as keys
        const key1 = {};
        const key2 = {};

        // Adding key-value pairs to the WeakMap
        weakMap.set(key1, "Value associated with key1");
        weakMap.set(key2, "Value associated with key2");

        // Retrieving values from the WeakMap
        console.log(weakMap.get(key1)); // Output: "Value associated with key1"

        // Let's assume key1 is no longer referenced elsewhere in the code
        key1 = null;

        // Because key1 is no longer referenced, it can be garbage collected,
        // and the corresponding entry in the WeakMap will automatically be removed.
        console.log(weakMap.get(key1)); // Output: undefined
----------------------------------------------

---->difference between the weakSet and Set

     Set: A Set holds strong references to the objects it contains. This means that as long as an object is stored in a Set,
      it will not be garbage collected, even if there are no other references to that object in your code. Objects stored in a 
      Set are kept alive.

     WeakSet: A WeakSet holds weak references to the objects it contains. This means that the presence of an object in 
     a WeakSet does not prevent it from being garbage collected if there are no strong references to it elsewhere in your code.
      Objects stored in a WeakSet are not kept alive solely by the WeakSet.

      Set: A Set is iterable, which means you can easily iterate through its elements using methods like forEach or a for...of loop.

      WeakSet: A WeakSet is not iterable. You cannot directly iterate through its elements, which makes it suitable for scenarios
     where you don't need to enumerate the objects it contains.

     Set: A Set can store values of any data type, including primitive values (e.g., numbers, strings) and objects.

     WeakSet: A WeakSet can only store objects. Primitive values are not allowed.

----------------------------------------------

---->difference between Map and weakMap

     Map: A Map allows keys to be of any data type, including objects, functions, and primitive values (e.g., numbers, strings).

    WeakMap: A WeakMap can only have objects as keys. Primitive values are not allowed as keys.

    Map: A Map holds strong references to its keys. This means that as long as a key is stored in a Map, it will not be garbage collected, even if there are no other references to that key in your code. Keys stored in a Map are kept alive.

    WeakMap: A WeakMap holds weak references to its keys. This means that the presence of a key in a WeakMap does not prevent
     it from being garbage collected if there are no strong references to it elsewhere in your code. Keys stored in a WeakMap are 
     not kept alive solely by the WeakMap.

----------------------------------------------

--->Factory funciton

    Certainly! A factory function in JavaScript is like a recipe for creating objects. It's a function that you can use to make many 
    similar objects quickly and easily.

     Imagine you want to make lots of toy cars. Instead of building each car from scratch every time, you create a toy car factory.
         The factory has instructions on how to make a toy car, like what color it should be and how many wheels it should have.

     In JavaScript, a factory function is similar. It's a function that you call to make objects. You give it some information, and it
         creates an object with that information. This way, you can make as many objects as you need without writing the same code over
          and over again.

     Here's a simple example:

    javascript
     // This is our factory function for creating people
    function createPerson(name, age) {
     // We create a new person object
      const person = {};

        // We fill in the details
        person.name = name;
        person.age = age;

        // We give the person a way to say hello
        person.sayHello = function () {
            console.log(`Hello, my name is ${person.name} and I am ${person.age} years old.`);
        };

        // Finally, we return the person we created
        return person;
        }

        // Now, we can use our factory function to make people
        const person1 = createPerson("John", 30);
        const person2 = createPerson("Alice", 25);

        // Each person has their own information and can say hello
        person1.sayHello(); // Output: "Hello, my name is John and I am 30 years old."
        person2.sayHello(); // Output: "Hello, my name is Alice and I am 25 years old."
        ```

        So, a factory function is like a template that helps you create objects with similar
         properties and behaviors without repeating yourself. It's a handy way to make objects in JavaScript!
----------------------------------------------

--->Throatling
       Imagine you have a button, and every time you click it, a function runs. If you click the button multiple times very quickly,
       the function may run many times in a short span, which could be overwhelming or inefficient.

       Throttling helps with this. It makes sure that the function runs at a maximum rate, like every 1 second,
       no matter how many times you click the button within that second. It slows down the execution rate.

        It's commonly used to optimize performance when dealing with events that can trigger rapidly, such as scroll events or resize events.
        no matter how fast you trigger it.

----------------------------------------------

debouncing

Imagine you have a button, and every time you press it, a function runs.
Debouncing is like waiting for a pause before taking action.
If you press the button multiple times quickly, debouncing makes sure the function only runs once after you stop pressing for a moment.
It's useful when you want to wait for a break in activity, like waiting for someone to finish typing in a search bar before searching.

----------------------------------------------
 Defer 

 Certainly! Let's break down the default behavior of script execution in more detail:

1. **HTML Parsing and Rendering:**
   - When a web browser loads a webpage, it starts by downloading the HTML file from the server.
   - As it downloads the HTML, it begins parsing it, which means it reads the HTML code and constructs a Document Object Model (DOM) 
   tree representing the structure of the webpage.
   - The browser also constructs a render tree, which is used to display the content on the screen.

2. **Script Encounters:**
   - While parsing the HTML, if the browser encounters a `<script>` element (which includes external scripts loaded via the `src` 
   attribute or inline scripts), it immediately stops parsing the HTML content.

3. **Script Download and Execution:**
   - The browser then initiates the download of the script file (if it's an external script) or executes the inline script.
   - Script execution can involve downloading and parsing additional resources, which may include other scripts, stylesheets,
    or external data.
   - The browser will execute the script's code as it's downloaded or parsed.

4. **Rendering Blockage:**
   - While the script is being executed, the rendering process is blocked. This means that the browser cannot update the DOM or render
     new content on the webpage.
   - If the script takes a long time to execute, it can cause a delay in rendering, making the webpage appear unresponsive or slow to load.

5. **Script Completion:**
   - Once the script has been executed, the browser continues parsing the HTML from where it left off.
   - After parsing the HTML and constructing the DOM, the browser can update the render tree and display the content on the screen.

 In summary, the default behavior of script execution in a web browser involves pausing the parsing and rendering of HTML when a `<script>`
  element is encountered. The browser then downloads and executes the script, which can potentially block the rendering of the webpage,
   especially if the script is large or contains complex operations.

 This behavior can lead to a less responsive user experience and slower page loading times, especially if scripts are placed in the `<head>`
 section of the HTML, as they can delay the rendering of the visible content. To mitigate this issue, developers use techniques like the `async`
  and `defer` attributes to control when and how scripts are executed, allowing the browser to continue rendering the webpage while scripts load and run.

----------------------------------------------
Function composition

Function composition in JavaScript is like building a sequence of actions by combining smaller functions. It's a way to take multiple functions and use
them together to create a new function that performs a series of operations in a specific order.

Here's a simple explanation with an example:

Imagine you're making a sandwich, and you have individual ingredients and steps to follow:

Spread peanut butter on one slice of bread.
Add jelly on top of the peanut butter.
Place another slice of bread on top.

----------------------------------------------

a literal is a direct way to write and represent a value in your code. It's like writing a value exactly
as it is, without any calculations or extra steps.
String Liter,Number Literals,Boolean Literes
Number Literals is used to represent Numbers . like that others case also.

----------------------------------------------


Use Struct (strict mode)
 It helps you catch common coding mistakes and prevents silent errors. For example, it makes sure you declare variables before using them.
 "use strict";

// This code runs with strict mode
x = 10; // Error: x is not defined

function doSomething() {
  y = 20; // Error: y is not defined
}

doSomething();
console.log(x); // This line won't be reached due to the errors

With strict mode enabled, both x and y cause errors because they are used without being declared. Strict mode helps you catch these kinds
 of issues early in development, making your code more reliable and less error-prone.

----------------------------------------------

Event bubbling is a concept in JavaScript where an event triggered on a nested or innermost element "bubbles" up through its ancestors
 in the DOM hierarchy, triggering their respective event handlers as well. This means that when an event occurs on an element inside another 
 element, it will also trigger the event on the outer elements in the nesting order, from the innermost to the outermost.

 <div id="outer">
  Outer Element
  <div id="inner">
    Inner Element
  </div>
</div>

const outerElement = document.getElementById("outer");
const innerElement = document.getElementById("inner");

outerElement.addEventListener("click", function () {
  console.log("Click event on outer element");
});

innerElement.addEventListener("click", function () {
  console.log("Click event on inner element");
});

If you click on the "Inner Element," the event will first trigger the inner element's click event handler,
 printing "Click event on inner element" to the console. Then, the event will bubble up to the outer element and 
 trigger its click event handler, printing "Click event on outer element" to the console.

----------------------------------------------

Evetnt propagation

Certainly! Event propagation in JavaScript refers to the way events travel through the DOM (Document Object Model) hierarchy. 
There are two main phases of event propagation: capturing phase and bubbling phase.

Capturing Phase: In this phase, the event travels from the outermost ancestor to the target element.

Bubbling Phase: In this phase, the event travels from the target element back up to the outermost ancestor.

const outerElement = document.getElementById("outer");
const innerElement = document.getElementById("inner");

outerElement.addEventListener("click", function () {
  console.log("Outer Element Clicked");
});

innerElement.addEventListener("click", function () {
  console.log("Inner Element Clicked");
});
element.addEventListener(event, listener, useCapture);
event: The event type (e.g., "click").
listener: The function to be called when the event is triggered.
useCapture: An optional boolean parameter that determines the phase to which the listener should be attached. If useCapture is true, the listener 
is attached to the capturing phase; if false or omitted, it's attached to the bubbling phase (which is the default).
Since you didn't set useCapture to true when adding event listeners, both of them are attached to the bubbling phase. As a result, 
you see the event propagation behavior I described earlier:

The capturing phase doesn't have any event listeners, so it doesn't log anything in this example.
The bubbling phase has event listeners on both the innerElement and the outerElement, and they log messages when the event bubbles up.
If you wanted to add event listeners to the capturing phase, you would explicitly set useCapture to true:

outerElement.addEventListener("click", function () {
  console.log("Outer Element Clicked - Capturing Phase");
}, true);

innerElement.addEventListener("click", function () {
  console.log("Inner Element Clicked - Capturing Phase");
}, true);

now the out put is 
"Outer Element Clicked - Capturing Phase"
"Inner Element Clicked - Capturing Phase"

----------------------------------------------
Generator function
A generator function in JavaScript is a special type of function that can be paused and resumed during its execution. 
It allows you to generate a sequence of values lazily, meaning you can produce values one at a time and only when needed, which 
can be particularly useful for dealing with large data sets or asynchronous operations.

function* generator(){
    let a=2
    while(a<5){
        yield ++a 
    }
}

let generat=generator()
console.log(generat.next().value)

console.log('hello')
console.log(generat.next().value)

----------------------------------------------

Regular Functions: Regular functions have their own this binding, which is determined by how the function is called.
 The value of this can vary based on the calling context (e.g., the object that calls the function or the global object).

Arrow Functions: Arrow functions do not have their own this binding. Instead, they inherit the this value from the surrounding
lexical context (the context in which they were created). This can be advantageous in certain scenarios, such as when working
with callbacks or event handlers.
----------------------------------------------

A pure function always produces the same output for the same input. It doesn't rely on any external state or data that may change over time. 
This property makes pure functions predictable, which is essential for debugging and testing.
// Example 1: Addition
function add(a, b) {
  return a + b;
}
----------------------------------------------

do...while loop guarantees that the block of code will execute at least once, even if the condition is initially false.
----------------------------------------------
In JavaScript, the finally block is used in conjunction with try...catch to specify a block of code that should be executed
 regardless of whether an exception (error) was thrown or not. This is useful for performing cleanup operations or releasing
  resources that need to be done no matter what.

try {
  // Code that may throw an exception
} catch (error) {
  // Code to handle the exception
} finally {
  // Code that will always run, whether there was an exception or not
}

----------------------------------------------

In pass by value, a copy of the actual data (the value) is passed to a function. This means that changes made to the parameter 
inside the function don't affect the original variable outside the function.
function doubleValue(num) {
  num = num * 2;
  return num;
}

let x = 5;
let result = doubleValue(x);

console.log(x);      // x remains 5 (unchanged)
console.log(result); // result is 10

In pass by reference, a reference to the original data (the memory location) is passed to a function. This means that changes made to the 
parameter inside the function affect the original variable outside the function.

function doubleArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = arr[i] * 2;
  }
}

let numbers = [1, 2, 3];
doubleArray(numbers);

console.log(numbers); // numbers is now [2, 4, 6]

----------------------------------------------
