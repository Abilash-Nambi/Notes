
----------------------------------------------------------------------

React is a JavaScript library for building user interfaces.
React is used to build single-page applications.
React allows us to create reusable UI components.

----------------------------------------------------------------------

Strict Mode in React is a developer tool that helps you identify potential problems in your code. It runs in development mode only 
and does not impact the production build.
When you enable Strict Mode, your console will show warnings and errors that are meant to help you catch 
and address issues early in the development process. 
When you enable Strict Mode, your console will show warnings and errors that are meant to help you catch and address 
issues early in the development process. 

----------------------------------------------------------------------

---> How does React Work?

React creates a VIRTUAL DOM in memory.

Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, 
before making the changes in the browser DOM.

React only changes what needs to be changed!

----------------------------------------------------------------------
---> DOM

In JavaScript, the Document Object Model (DOM) is a programming interface that represents the structure of a web page and
allows you to interact with and manipulate the content and elements of that page.
.It provides a structured representation of a web page, where each HTML element, attribute, and piece of content is represented as an object.
Think of the DOM as a tree structure, where the entire web page is represented as a tree of nodes. The top node, or the root, is called the document object.
HTML elements, such as headings (<h1>), paragraphs (<p>), and images (<img>), are represented as nodes in the DOM tree. Each node can have child nodes,
which represent elements contained within it.

----------------------------------------------------------------------

---> Virtual Dom

in React, the Virtual DOM (short for "Virtual Document Object Model") is a key concept that helps improve the performance and 
efficiency of rendering updates in web applications. It's a virtual representation of the actual DOM in memory, and it plays a
crucial role in React's ability to efficiently update the user interface.

When you make changes to a React component (e.g., updating the state or props), React doesn't immediately make changes to the real DOM.
Instead, it updates the Virtual DOM.

Initial Render:

When you initially load a React application or component, React creates a Virtual DOM representation of the entire component hierarchy. 
This Virtual DOM is a lightweight, in-memory JavaScript representation of the actual DOM.
Component Updates:

When you interact with a React component, such as changing its state or passing new props, React needs to update the user interface to reflect these changes.
Creating a New Virtual DOM:

When a change occurs, React creates a new Virtual DOM tree to represent how the component should look after the change. 
This new Virtual DOM tree reflects the updated state or props.
Diffing and Reconciliation:

React employs a process called "reconciliation" to compare the new Virtual DOM with the previous Virtual DOM. 
It identifies the differences (or "diffs") between the two Virtual DOM trees.
Determining Minimal Updates:

The diffing process determines the minimal set of changes needed to bring the new Virtual DOM in line with
the updated state. It calculates what elements have been added, changed, or removed.
Batching Updates:

React batches multiple updates together for efficiency. Instead of immediately updating the real DOM with every change, 
it queues these updates, allowing React to optimize the rendering process.
Updating the Real DOM:

Once the differences are identified, React applies the necessary changes to the real DOM. It directly updates the browser's
DOM only with the specific changes required to reflect the new Virtual DOM.

----------------------------------------------------------------------

---> Diff b/w diffing and reconcilation

Diffing: This is the process of comparing the new Virtual DOM tree (generated after a component update) with the previous Virtual DOM tree
(representing the component's previous state). The goal of diffing is to identify the differences between these two Virtual DOM trees efficiently.
Specifically, React's diffing algorithm aims to find which elements or components have been added, removed, or changed between the two trees. 
Diffing is focused on computing the minimal set of changes needed to update the Virtual DOM.

Reconciliation: Reconciliation is the subsequent step in the process. Once React has identified the differences through diffing, it needs to apply
these changes to the actual, real DOM. Reconciliation is the process of taking the information about the differences identified during diffing and
using it to update the real DOM to match the new Virtual DOM. This process often involves creating, updating, or removing DOM elements or components,
as needed.

In essence, diffing is about comparing the  previous and new Virtual DOM trees and figuring out what's different between them, whereas reconciliation
is about applying those differences to the real DOM. 
----------------------------------------------------------------------

---> JSX 

JSX stands for JavaScript XML.
JSX allows you to write HTML-like code within your JavaScript code, making it easier to define the structure and content of user interfaces.

----------------------------------------------------------------------
---> Components

Components are independent and reusable bits of code.
In React, components are the building blocks of user interfaces. They are reusable, self-contained pieces of code
Function Components (Also known as "Stateless Functional Components")
Class Components (Also known as "Stateful Components"):

----------------------------------------------------------------------
---> Pure Component

A Pure Component is a special type of class component in React that is designed to optimize rendering by reducing unnecessary re-renders.
It does this by automatically performing a shallow comparison of its props and state to determine whether it should update and re-render. 
If the props and state haven't changed, a Pure Component won't re-render, improving performance.

Pure Components are a way to optimize your application's performance by reducing unnecessary re-renders,
 especially when dealing with frequently updated data or props. 

----------------------------------------------------------------------
---> Higher-Order Components

Higher-Order Components are a powerful mechanism for enhancing and reusing the functionality of components in React applications.
HOCs are not components themselves but are functions that take a component as input and return a new component with enhanced functionality. 
HOCs are components that wrap other components. 
HOCs are functions that take a component as input and return a new component with additional props, behavior, 
or functionality. They wrap the original component.


import React,{useState} from 'react' 

function HOC(WrappedComponent){
  function Counter(props){
    const [count,setCount] = useState(0)
    const handleAdd = () =>{
      setCount(count+1)
    }
    return(
      <div>
        <WrappedComponent count={count} handleAdd={handleAdd} />
      </div>
    )
  }
  return Counter
}

export default HOC;

import React, { useState } from 'react'
import './App.css'
import HOC from './HOC'

function B(props){
  const {count,handleAdd} = props
  return (
    <div className="maindiv">
      <h3>This is B {count}</h3>
      <button onClick={handleAdd}>Add</button>
    </div>
  )
}
export default HOC(B);


import React, { useState } from 'react'
import './App.css'
import HOC from './HOC'

function A(props){
  const {count,handleAdd} = props
   return(
     <div className="maindiv">
       <h3>This is A {count}</h3>
       <button onClick={handleAdd}>Add</button>
      </div>
   )  
}

export default HOC(A);


----------------------------------------------------------------------
---> render prop 

A "render prop" is a pattern in React where a component takes a function as a prop and calls that function to render some part of its content.
The function, often called the "render prop," is used to provide data or behavior to the component that incorporates it. 

Scenario: You want to create a Toggle component that can be used in various parts of your application to toggle the visibility of different elements. 
However, you want the content that gets displayed when the toggle is on or off to be completely customizable based on where you use the Toggle component.

----------------------------------------------------------------------
---> props

in React, "props" is short for "properties," and it refers to a mechanism for passing data from one component to another. Props allow 
you to send data from a parent component to a child component, enabling you to customize and configure the behavior and appearance of components.

----------------------------------------------------------------------
---> Props drilling

Props drilling, also known as "prop drilling" or "component drilling," is a term used in React to describe a situation where data needs
to be passed through multiple layers of components. This can occur when you have a hierarchy of components, and you need to send data
from a top-level component to a deeply nested one.

----------------------------------------------------------------------
---> Conditional rendering

Conditional rendering in React is the process of determining whether or not a component or a part of a component should be displayed
or rendered based on certain conditions or logic. 
Using the if Statement or Conditional (Ternary)
OpeUsing && Logical Operator:rator:

----------------------------------------------------------------------
---> React Router
React Router is a popular library for handling routing and navigation in React applications
with specific URLs. React Router is widely used for building single-page applications (SPAs) and provides a way to navigate
between different views or pages without causing a full page refresh.
<Router>
    <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route path="/contact" component={Contact} />
    </Switch>
</Router>

----------------------------------------------------------------------
---> React.memo

In React, React.memo is a higher-order component (HOC) that is used to optimize the rendering performance of functional components by preventing
unnecessary re-renders. It's similar in concept to PureComponent for class components but is used with functional components. React.memo is part
of the React library and doesn't require any additional installations.
In summary, React.memo is a powerful tool for optimizing the performance of functional components by reducing unnecessary re-renders.
It's especially helpful in scenarios where you want to prevent re-renders when props don't change.


--->React memo

import React, { useState } from 'react'
import {MemoizedChild} from './Child'

const Parent =()=>{
  const [count,setCount] = useState(0)
  const [name,setName] = useState("jithin")
  const handleCount = () =>{
    setCount(count+1)
  }
  const handleName =()=>{
    setName("Jinto")
  }
  console.log("parent rendering")
  return(
    <div>
      <button onClick={handleCount}>Add count - {count}</button>
      <button onClick = {handleName}> Change name </button>
      <MemoizedChild name={name}/>
    </div>
  )
}
export default Parent


import React from 'react' 

export const Child = (props) =>{
  console.log("child rendering")
  return(
    <div>
      <p>{props.name}</p>
    </div>
  )
}

export const MemoizedChild = React.memo(Child)
----------------------------------------------------------------------
---> Hooks

React Hooks are a set of functions that allow you to use state and other React features in functional components.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.

----------------------------------------------------------------------
---> State

State generally refers to data or properties that need to be tracking in an application.
State in React holds dynamic data that can change during a component's lifecycle.
data of a specific component.
used to contain data or information about the component. A component’s state can change over time; whenever it changes, the component re-renders. 
----------------------------------------------------------------------
--->useState

useState is a React Hook that allows you to add state to functional components. It's used to declare and manage local component state within 
functional components,
It returns an array with two values: the current state and a function to update it.
The Hook takes an initial state value as an argument and returns an updated state value whenever the setter function is called. 

----------------------------------------------------------------------
--->child parent relation

When ever we want a component inside any other component it is called child parent relationship.

----------------------------------------------------------------------
--->state vs variable

when a normal variable or js variable get updates,react doenst care,it doest make changes in frontend.Reacts only looks states to change.
whenever the states changes it will rerender the component.

----------------------------------------------------------------------

--->useEffect

useEffect is a React Hook that allows you to perform side effects in functional components. Side effects include data fetching,
DOM manipulation, setting up subscriptions, and any other interactions that require interaction with the external world. useEffect
replaces the lifecycle methods that are used in class components to manage side effects.

ComponentDidMount:

useEffect(() => {
    // ComponentDidMount logic here
    console.log('Component has mounted.');
  }, []);

ComponentDidUpdate

 useEffect(() => {
    // componentDidUpdate logic here
    console.log('Component has updated. Count is now: ' + count);
  }, [count]);

ComponentWillUnmount

useEffect(() => {
    // ComponentDidMount logic
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();

    // ComponentWillUnmount cleanup
    return () => {
      console.log('Component is unmounting.');
      // Perform cleanup actions here, such as canceling network requests or clearing timers.
    };
  }, []);

----------------------------------------------------------------------
--->useContext

useContext is a React Hook that allows you to access the value of a context that has been created with React.createContext(). 
Context in React is a way to share data, settings, or configuration information between components without the need to pass 
props explicitly at every level of the component tree.

First, you need to create a context using React.createContext(). This function returns an object with Provider and Consumer components.Wrap the part 
of your component tree where you want to provide a context value with a Provider. The value prop of the Provider sets the value that will be shared 
with components consuming the context.In any functional component that is a descendant of the Provider, you can use the useContext hook to access the context's value.
SomeContext.Consumer is an alternative and rarely used way to read the context value.

----------------------------------------------------------------------
--->useRef

useRef is a versatile hook that is often used for tasks such as working with form inputs, managing focus, integrating with third-party 
libraries that require direct DOM manipulation, or storing values that need to persist across renders.
useRef() only returns one item. It returns an Object called current.

Creating a Reference:
You create a reference using the useRef function. This function returns an object that has a .current property.

jsx
Copy code
const myRef = useRef(initialValue);
myRef: This is the reference object.
initialValue: This is the initial value of the reference, which is typically null.
Accessing DOM Elements:
You can attach a ref attribute to a JSX element, allowing you to reference that DOM element using the myRef.current property.

It can be used to store a mutable value that does not cause a re-render when updated.

It can be used to access a DOM element directly.



jsx
Copy code
import React, { useRef } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
In this example, we create a reference to the input element with inputRef and use inputRef.current to access and manipulate the DOM element.

import React,{useRef} from "react";
export default function App() {
  const inputElement = useRef()
  const handleClick = () =>{
    console.log(inputElement.current.value)
  }
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <input type="text" ref={inputElement}/>
      <button onClick={handleClick}>click me</button>
      {/* <p>{inputElement.current.value}</p> */}
    </div>
  );
}
----------------------------------------------------------------------
--->useReducer

useReducer is a React Hook that is used for managing complex state logic in a more organized and predictable way, especially when state 
transitions involve multiple actions. It is often used as an alternative to useState when state management becomes more complex. useReducer 
is inspired by the concept of reducers in Redux, a popular state management library.

Here's a detailed explanation of useReducer in a simple way:

Importing the Hook:
First, you need to import useReducer from the react library.

jsx
Copy code
import React, { useReducer } from 'react';
Defining a Reducer Function:
A reducer function is a pure JavaScript function that takes two arguments: the current state and an action. It calculates the new state based on the 
action and returns it.

jsx
Copy code
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}
In this example, the reducer function takes an action object with a type property and performs state updates based on the action type.

Using useReducer:
You call useReducer to initialize your state and specify the reducer function.

jsx
Copy code
const [state, dispatch] = useReducer(reducer, initialState);
state: The current state object.
dispatch: A function that you use to dispatch actions to update the state.
reducer: The reducer function you defined earlier.
initialState: The initial state of the component.
Dispatching Actions:
To update the state, you call the dispatch function and pass an action object as an argument. The reducer function then handles the action and returns the new state.

jsx
Copy code
dispatch({ type: 'INCREMENT' });
dispatch({ type: 'DECREMENT' });
In this example, calling dispatch with an action type of 'INCREMENT' or 'DECREMENT' triggers the state to be updated accordingly.

Using the State:
You can use the state object to access the current state values in your component.

jsx
Copy code
return (
  <div>
    <p>Count: {state.count}</p>
    <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
    <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
  </div>
);
In this example, we display the current count from the state, and the buttons dispatch actions to update it.


import React, { useReducer } from 'react'

const reducer =(state,action)=>{
   switch(action.type){
     case "increment":
       return {count:state.count+1}
     case "decrement":
       return {count:state.count-1}
     case "reset":
       return {count:0}
     default:
       return state;
   }
}
const App =()=>{
  const [state,dispatch] = useReducer(reducer,{count:0})
  return(
     <div>
       <button onClick={()=>dispatch({type:"increment"})}>Increment</button>
       <button onClick={()=>dispatch({type:"decrement"})}>decrement</button>
       <button onClick={()=>dispatch({type:"reset"})}>reset</button>
       <p>{state.count}</p>
    </div>
  )
}
export default App;


----------------------------------------------------------------------
--->useCallback

useCallback is a React Hook used to optimize the performance of your components by memoizing (caching) 
functions so that they are not recreated on every render. It's particularly useful when you need to pass
functions as props to child components, ensuring that these functions do not trigger unnecessary re-renders.

import React, { useCallback, useState } from 'react'

Certainly, here's an example that illustrates how useCallback can be useful for optimizing child components when you pass functions as props:

jsx
Copy code
import React, { useState, useCallback } from "react";

function ChildComponent({ onClick }) {
  console.log("ChildComponent rendering");
  return <button onClick={onClick}>Click me</button>;
}

function App() {
  const [count, setCount] = useState(0);

  // Without useCallback, this function would be recreated on every render of App
  const handleClick = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return (
    <div className="App">
      <h1>useCallback Example</h1>
      <p>Count: {count}</p>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}

export default App;
In this example:

handleClick is defined in the App component and passed as a prop to the ChildComponent.

handleClick is memoized using useCallback with its dependency array [count]. This means that the function is recreated only when count changes.

ChildComponent receives the onClick function as a prop and uses it to handle the button's click event.

The ChildComponent displays a button that triggers the onClick function when clicked.

Because we've memoized the handleClick function using useCallback, ChildComponent won't re-render unnecessarily 
when the App component re-renders. It will continue using the same function reference unless the count state changes. 
This helps optimize the performance of child components, especially when dealing with more complex components or a large number of child components.

----------------------------------------------------------------------
--->diff bw useMemo and useCallback

useCallback is for memoizing functions, while useMemo is for memoizing any value.
Both hooks take a function as their first argument and an array of dependencies as their second argument.
useCallback is typically used when you want to optimize functions to avoid unnecessary re-renders, especially in the context of passing functions as props.
useMemo is more general and can be used to memoize any value or result, such as the result of a complex calculation or an object that depends on certain values.
The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns 
a memoized function. You can learn more about useCallback


To illustrate how useMemo can help avoid unnecessary re-renders, let's consider an example where a computationally expensive calculation 
is memoized to improve performance. Here's a simple example:

jsx
Copy code
import React, { useState, useMemo } from "react";

function App() {
  const [number, setNumber] = useState(5);
  const [multiplier, setMultiplier] = useState(2);

  // Calculate the result using useMemo
  const result = useMemo(() => {
    console.log("Calculating result...");
    // Simulate a computationally expensive operation
    let computedResult = number;
    for (let i = 0; i < 100000000; i++) {
      computedResult *= multiplier;
    }
    return computedResult;
  }, [number, multiplier]);

  return (
    <div className="App">
      <h1>useMemo Example</h1>
      <p>Number: {number}</p>
      <p>Multiplier: {multiplier}</p>
      <p>Result: {result}</p>
      <button onClick={() => setNumber(number + 1)}>Increment Number</button>
      <button onClick={() => setMultiplier(multiplier + 1)}>Increment Multiplier</button>
    </div>
  );
}

export default App;
In this example:

We have a computationally expensive operation simulated by the loop that multiplies number by multiplier many times.

Without useMemo, this expensive calculation would be performed on every render, even if number or multiplier haven't changed.

With useMemo, the calculation is performed only when number or multiplier changes. If you click the "Increment Number" or "Increment Multiplier" button, the calculation is triggered. However, if you click them without any changes to the dependencies, the calculation is not performed. This avoids unnecessary re-renders and improves performance.

You'll see that the "Calculating result..." log message is only displayed when the calculation is performed, and it's not displayed on every render, demonstrating how useMemo helps avoid unnecessary re-renders when the dependencies remain the same.
----------------------------------------------------------------------
--->diff bw React memo and useMemo

useMemo:

useMemo is a hook in React used to memoize the result of a computation and avoid re-calculating that result on every render.
It is typically used for optimizing performance when you have a costly computation that depends on some values, and you want to compute the 
result only when the dependencies change.
useMemo is used to memoize values, such as computed values or derived data, so that they are cached and only re-calculated when the dependencies change.
It's primarily used for optimizing calculations and data transformations within a component.
Example:

jsx
Copy code
const memoizedValue = useMemo(() => computeExpensiveValue(dep1, dep2), [dep1, dep2]);
React.memo:

React.memo is a higher-order component in React that is used to memoize functional components, preventing them from re-rendering if their 
props have not changed.
It is typically used for optimizing the performance of functional components by preventing unnecessary re-renders.
React.memo is used to memoize entire components, ensuring that a component re-renders only if its props have changed.
It's useful for functional components that receive the same props but don't need to re-render unless those props change.
Example:

jsx
Copy code
const MemoizedComponent = React.memo(MyComponent);
In summary, useMemo is used to memoize values or results of calculations, while React.memo is used to memoize entire functional components. They are both valuable tools for performance optimization in React, but they serve different purposes and are used in different contexts. You can even use them together in the same component if needed, where useMemo can optimize calculations within a memoized component.


----------------------------------------------------------------------
--->Custom Hooks

They enable you to create your own hooks, making it easier to share and reuse code across different components and applications. 
Custom Hooks follow the same rules as built-in React hooks, but you can define your own behavior.
When you have component logic that needs to be used by multiple components, we can extract that logic to a custom Hook.
Custom Hooks start with "use". Example: useFetch.

import React,{useState} from 'react' 

const UserCounter = () =>{
  const [count,setCount] = useState(0)
  const handleDec=()=>{
    setCount(count-1)
 }
 const handleInc=()=>{
   setCount(count+1)
 }
  return {count,handleDec,handleInc}
}


export default UserCounter;

import React, { useState } from 'react'
import UserCounter from './UserCounter'
function Counter(){
  const {count,handleDec,handleInc} = UserCounter() 
  return(
    <div>
      <p>Count - {count}</p>
      <button onClick={handleInc}>Increment</button>
      <button onClick={handleDec}>decrement</button>
    </div>
  )
}
export default Counter 

----------------------------------------------------------------------
--->Context API vs Redux

Context API and Redux are both state management solutions for React applications, 

With Redux, the entire state of your application is stored in a single place, making it easily accessible to any 
component without the need to pass props around. It operates based on three core concepts:

Actions
Reducers
Store
Actions represent events that send data to the Redux store. They can be triggered by user interactions or called directly by your 
application. Each action has a unique type and a payload associated with it.
----------------------------------------------------------------------
--->state vs props

Local to the Component: State is an internal data storage mechanism that is specific to a particular component. It is maintained within the component 
itself and is not accessible to other components.

Mutable: State is mutable and can be modified within the component by calling this.setState(). When the state is updated, React will re-render the 
component to reflect the changes.
----------------------------------------------------------------------
--->diff b/w useMemo and React.memo


useMemo: It is a hook used for memoizing the result of a function or a computation. It allows you to optimize the performance 
of your component by caching the result of a function and recalculating it only when the dependencies change.

React.memo: It is a higher-order component used to optimize functional components by preventing unnecessary re-renders. It memoizes 
the rendering output of a component and only re-renders when the component's props change.

----------------------------------------------------------------------
--->Cleanup function

Certainly! In a simpler way, a cleanup function in React is like tidying up after yourself when you're done with something. It's a 
piece of code that you write to clean up resources or cancel tasks when a part of your web page (a component) is no longer needed

----------------------------------------------------------------------
--->Fragments

div. Fragments allow you to avoid adding unnecessary elements to the DOM structure.

----------------------------------------------------------------------
--->Controlled components and uncontrolled components

Controlled components and uncontrolled components are two approaches to managing form elements (like input fields, checkboxes, and radio buttons) 
in a React application.
In a controlled component, React controls the form element's value by maintaining it in the component's state. You handle changes by defining 
event handlers and updating the state. 
In an uncontrolled component, you let the HTML element maintain its state. You don't control the form element's value with React state. Instead, 
you directly access the element's value through references or DOM manipulation when needed.



Controlled Components:

In a controlled component, the value of the form element is controlled by React. This means that you store 
the input's value in a state variable and update the value through the onChange event handler. When the state changes, the input element updates accordingly.

Here's a simple example of a controlled component:

jsx
Copy code
import React, { useState } from "react";

function ControlledInput() {
  const [inputValue, setInputValue] = useState("");

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };

  return (
    <div>
      <label>Controlled Input:</label>
      <input type="text" value={inputValue} onChange={handleChange} />
      <p>You typed: {inputValue}</p>
    </div>
  );
}

export default ControlledInput;
In this example:

The inputValue is stored in a state variable using useState.

The <input> element has its value attribute set to inputValue, which makes it a controlled component.

The onChange event handler updates the inputValue state variable when the user types in the input field.

As you type, the input value is controlled by React, and the changes are reflected in the paragraph below the input.

Uncontrolled Components:

In an uncontrolled component, the input value is not controlled by React. Instead, you let the DOM handle the input's value, 
and you access it through a ref. Uncontrolled components are typically used when you need to integrate with non-React code or 
when you want a more imperative approach.

Here's a simple example of an uncontrolled component:

jsx
Copy code
import React, { useRef } from "react";

function UncontrolledInput() {
  const inputRef = useRef();

  const handleShowValue = () => {
    alert("Input Value: " + inputRef.current.value);
  };

  return (
    <div>
      <label>Uncontrolled Input:</label>
      <input type="text" ref={inputRef} />
      <button onClick={handleShowValue}>Show Value</button>
    </div>
  );
}

export default UncontrolledInput;
In this example:

The <input> element is uncontrolled because it doesn't have a value attribute and isn't managed by React.

Instead, we use useRef to create a reference to the input element.

When the "Show Value" button is clicked, we access the input's value using inputRef.current.value.
----------------------------------------------------------------------


The React Profiler is a tool that is part of React's developer tools suite. It is designed to help you analyze and optimize 
the performance of your React applications. Profiling your application can be essential to ensure that it runs smoothly, especially 
in large and complex applications. 

----------------------------------------------------------------------

Lazy loading in React is a technique used to improve the performance of your web application. It allows you to load certain parts of your 
application only when they are actually needed, rather than loading everything when the page first loads. This can make your app faster and 
more efficient because it reduces the initial load time.

Create a React Project:

If you don't have a React project set up, you can create one using Create React App:

bash
Copy code
npx create-react-app lazy-loading-example
cd lazy-loading-example
Create Components:

Create two components that we'll load lazily.

jsx
Copy code
// ComponentA.js
import React from "react";

const ComponentA = () => {
  return <div>Component A</div>;
};

export default ComponentA;
jsx
Copy code
// ComponentB.js
import React from "react";

const ComponentB = () => {
  return <div>Component B</div>;
};

export default ComponentB;
Create the Main Component:

Create a main component where you'll use lazy loading to load the other components.

jsx
Copy code
// App.js
import React, { lazy, Suspense } from "react";

const ComponentA = lazy(() => import("./ComponentA"));
const ComponentB = lazy(() => import("./ComponentB"));

function App() {
  return (
    <div>
      <h1>Lazy Loading Example</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <ComponentA />
        <ComponentB />
      </Suspense>
    </div>
  );
}

export default App; 

----------------------------------------------------------------------
Webpack

It takes all of the individual JavaScript files and other assets in a project, such as images and CSS, and combines them into a single 
bundle that can be loaded by the browser. Webpack also has the ability to transpile modern JavaScript code (such as ES6) into older 
versions that can be understood by older browsers.

Loaders: If your code uses modern features like JSX and ES6 that browsers can't understand directly, Webpack uses "loaders" to process these files. 
For example, it might use a Babel loader to convert JSX and ES6 into plain JavaScript that browsers can run.

----------------------------------------------------------------------
--->PropTypes

PropTypes provide a level of type checking for the props passed to a React component. They help ensure that the props conform to the expected data types. 
import PropTypes from 'prop-types';

MyComponent.propTypes = {
  stringProp: PropTypes.string,
  numberProp: PropTypes.number,
  boolProp: PropTypes.bool,
  arrayProp: PropTypes.array,
  objectProp: PropTypes.object,
  functionProp: PropTypes.func,
};


PropTypes in React functional components are used to specify the expected data types and, optionally, additional validation rules 
for the props that a component should receive. They help catch errors and ensure that the component is used correctly. Here's how 
to use PropTypes in a functional component with an example:

First, make sure to import PropTypes from the prop-types library:

javascript
Copy code
import PropTypes from 'prop-types';
Let's create a simple functional component and define PropTypes for its props:

javascript
Copy code
import React from 'react';
import PropTypes from 'prop-types';

function Greeting(props) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>You are {props.age} years old.</p>
    </div>
  );
}

Greeting.propTypes = {
  name: PropTypes.string.isRequired, // name should be a required string
  age: PropTypes.number, // age should be a number (optional)
};

export default Greeting;

----------------------------------------------------------------------

Axios provides a convenient way to cancel HTTP requests using cancel tokens. This can be helpful when you need to cancel ongoing requests, 
especially in scenarios like user-initiated actions or when navigating away from a page. To use Axios cancel tokens, you'll need to create a 
cancel token and attach it to your request.

Here's how to use Axios cancel tokens:

Import Axios:

First, make sure to import Axios if you haven't already:

javascript
Copy code
import axios from 'axios';
Create a Cancel Token:

You can create a cancel token using the axios.CancelToken.source factory method:

javascript
Copy code
const { token, cancel } = axios.CancelToken.source();
The token is the cancel token itself, and cancel is a function to cancel the request.

Attach Cancel Token to the Request:

When making an Axios request, you can attach the cancel token to the cancelToken option in the request configuration:

javascript
Copy code
axios.get('/your/api/endpoint', {
  cancelToken: token,
})
  .then(response => {
    // Handle the successful response
  })
  .catch(error => {
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
    } else {
      // Handle other errors
    }
  });
Cancel the Request:

To cancel the request, you can call the cancel function. This can be triggered, for example, when a user navigates away from 
the page or performs a specific action:

cancel('Request canceled by the user');
When the request is canceled, the promise will reject with an error object that you can handle in the catch block. You can check 
if the error is a cancel error using axios.isCancel(error).

Here's a complete example of using Axios cancel tokens:

javascript
Copy code
import axios from 'axios';

function makeRequest() {
  const { token, cancel } = axios.CancelToken.source();

  axios.get('/your/api/endpoint', {
    cancelToken: token,
  })
    .then(response => {
      // Handle the successful response
      console.log('Response:', response.data);
    })
    .catch(error => {
      if (axios.isCancel(error)) {
        console.log('Request canceled:', error.message);
      } else {
        console.error('Request failed:', error);
      }
    });

  // Simulate cancelling the request (e.g., user action)
  setTimeout(() => {
    cancel('Request canceled by the user');
  }, 1000);
}

makeRequest();
In this example, we create a request, set a timeout to cancel it after 1 second, and handle both the successful response 
and the canceled request using Axios cancel tokens.


----------------------------------------------------------------------
fetch vs axios

Rich Feature Set: Axios has a more extensive feature set, including automatic transformation of response data to JSON, 
support for request and response interceptors, request cancellation, and more.

HTTP Error Handling: Axios provides better HTTP error handling and allows you to intercept and customize error responses.


exmple of fetch:

useEffect(() => {
    // Using the fetch API to make a GET request
    fetch("https://jsonplaceholder.typicode.com/posts/1")
      .then((response) => response.json())
      .then((data) => {
        setData(data);
      })
      .catch((error) => {
        console.error("Error:", error);
      });
  }, []);

----------------------------------------------------------------------

axios interceptors

  axios.interceptors.request.use(function (config) {
    // Do something before request is sent
    return config;
  }, function (error) {
    // Do something with request error
    return Promise.reject(error);
  });

// Add a response interceptor
axios.interceptors.response.use(function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });


axios.interceptors.request.use((config)=>{
  
  return config
},error=>{
  return Promise.reject(error)
})

----------------------------------------------------------------------

shadow dom

In React, you can use the Shadow DOM with a web component. A web component is like a special HTML element that you create. 
Inside this special HTML element, you can put your own styles and behavior. This special HTML element is encapsulated, meaning 
its styles and code won't affect the rest of your web page, and vice versa.

----------------------------------------------------------------------
React Fiber

Of course, React is a popular JavaScript library that is used by developers to create complex and modern UIs (user interfaces). 
To identify which elements are to be rendered after certain changes are made by the developer, React uses a "reconciler", 
an algorithm that helps it compare two DOM trees and diff them with one another. React Fiber helps do this better.

----------------------------------------------------------------------

React is a powerful library for building dynamic web applications, but it does have some limitations and challenges, especially when 
it comes to initial loading and SEO (Search Engine Optimization). Here are the limitations and challenges in these areas:

Initial Load Performance:

Initial Bundle Size: React applications can have relatively large initial bundle sizes, especially when using many third-party libraries 
and dependencies. This can result in longer load times for users, especially on slower internet connections.

Client-Side Rendering (CSR): React primarily relies on client-side rendering, which means that the initial rendering of the page happens 
in the user's browser. This can lead to slower initial load times, particularly on devices with limited resources or slower CPUs.

First Contentful Paint (FCP): Achieving a fast FCP (when the browser displays the first content on the page) can be a challenge in React 
applications, as they often require more JavaScript to render content compared to server-side rendering.

SEO(Search Engine Optimization):

Initial HTML: React's client-side rendering approach can affect SEO because search engine crawlers often need to see the initial HTML content to index a page properly. React applications initially render with empty or minimal HTML content, which can lead to SEO issues.

Server-Side Rendering (SSR) Complexity: To improve SEO, many React applications implement server-side rendering (SSR), which can be complex to set up and maintain. SSR requires server infrastructure and can increase the complexity of your application.

JavaScript Dependency: Even with SSR, React applications may rely heavily on JavaScript to render content. This can still pose SEO challenges, as search engines may not fully process and execute JavaScript.

----------------------------------------------------------------------
Automatic batching

Automatic batching includes batching state updates in a non-event handler function. It happens such that only one re-render is required instead of 
several re-renders for each state update.

called transition to help distinguish between urgent and non-urgent updates.

Urgent updates like typing, clicking, or pressing are expected to respond immediately on the screen.

Non—urgent updates are displaying the list of users, where a slight delay can be acceptable, and doesn’t expect to see every intermediate value on screen.

useTransition Hook:
So let me give you an example: if you are doing a task and another urgent task comes in that has a higher priority, react will 
stop that task and work on the higher priority task and then start that task again.

Suspense
Before react 18 was introduced, if one component of an app was slow, it slowed down the entire app, but with react 18, 
if one component is slow, it will not slow down the entire App. Suspense allows you to instruct React to send HTML for other 
components, such as a loading spinner, before sending HTML for the placeholder. The server renderer will then insert its HTML 
into the same stream once the slow component is prepared and has fetched its data.


----------------------------------------------------------------------

React 18, on the other hand, introduces concurrent rendering. This new mode enables React to interrupt a rendering process to handle more 
urgent tasks, like responding to user input. It's like having a superpower that allows React to be in multiple places at the same time.

----------------------------------------------------------------------

Code splitting in Webpack is a technique used to optimize the performance and loading speed of web applications by splitting the code into smaller, 
more manageable chunks. Instead of bundling the entire application into a single JavaScript file, you break it down into smaller parts and load 
them on-demand as needed. This can significantly reduce the initial load time and improve the user experience.

----------------------------------------------------------------------

prop.children in React is a special property that allows child components to render whatever content was passed to them by their parent component.
const ParentComponent = () => {
  return (
    <div>
      <ChildComponent>
        <h1>Hello, world!</h1>
        <p>This is some text.</p>
      </ChildComponent>
    </div>
  );
};

const ChildComponent = (props) => {
  return (
    <div>
      {props.children}
    </div>
  );
};
----------------------------------------------------------------------

The createRoot() function in React is used to create a root for a React application. A root is a DOM node that React will manage. 
You can think of it as the point of entry for your React app into the DOM.

There are a few reasons why you would use createRoot():

To render React content into a DOM node.
To hydrate React content that was rendered on the server.
To use new features of React 18, such as concurrent rendering.

----------------------------------------------------------------------
----------------------------------------------------------------------

