
----------------------------------------------------------------------

React is a JavaScript library for building user interfaces.

React is used to build single-page applications.

React allows us to create reusable UI components.

----------------------------------------------------------------------

---> How does React Work?

React creates a VIRTUAL DOM in memory.

Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, 
before making the changes in the browser DOM.

React only changes what needs to be changed!
----------------------------------------------------------------------
---> DOM

In JavaScript, the Document Object Model (DOM) is a programming interface that represents the structure of a web page and
 allows you to interact with and manipulate the content and elements of that page.
. It provides a structured representation of a web page, where each HTML element, attribute, and piece of content is represented as an object.
Think of the DOM as a tree structure, where the entire web page is represented as a tree of nodes. The top node, or the root, is called the document object.
HTML elements, such as headings (<h1>), paragraphs (<p>), and images (<img>), are represented as nodes in the DOM tree. Each node can have child nodes,
 which represent elements contained within it.

----------------------------------------------------------------------

---> Virtual Dom

in React, the Virtual DOM (short for "Virtual Document Object Model") is a key concept that helps improve the performance and 
efficiency of rendering updates in web applications. It's a virtual representation of the actual DOM in memory, and it plays a
crucial role in React's ability to efficiently update the user interface.

When you make changes to a React component (e.g., updating the state or props), React doesn't immediately make changes to the real DOM.
Instead, it updates the Virtual DOM.

Initial Render:

When you initially load a React application or component, React creates a Virtual DOM representation of the entire component hierarchy. 
This Virtual DOM is a lightweight, in-memory JavaScript representation of the actual DOM.
Component Updates:

When you interact with a React component, such as changing its state or passing new props, React needs to update the user interface to reflect these changes.
Creating a New Virtual DOM:

When a change occurs, React creates a new Virtual DOM tree to represent how the component should look after the change. 
This new Virtual DOM tree reflects the updated state or props.
Diffing and Reconciliation:

React employs a process called "reconciliation" to compare the new Virtual DOM with the previous Virtual DOM. 
It identifies the differences (or "diffs") between the two Virtual DOM trees.
Determining Minimal Updates:

The diffing process determines the minimal set of changes needed to bring the new Virtual DOM in line with
 the updated state. It calculates what elements have been added, changed, or removed.
Batching Updates:

React batches multiple updates together for efficiency. Instead of immediately updating the real DOM with every change, 
it queues these updates, allowing React to optimize the rendering process.
Updating the Real DOM:

Once the differences are identified, React applies the necessary changes to the real DOM. It directly updates the browser's
DOM only with the specific changes required to reflect the new Virtual DOM.

----------------------------------------------------------------------

---> Diff b/w diffing and reconcilation

Diffing: This is the process of comparing the new Virtual DOM tree (generated after a component update) with the previous Virtual DOM tree
(representing the component's previous state). The goal of diffing is to identify the differences between these two Virtual DOM trees efficiently.
Specifically, React's diffing algorithm aims to find which elements or components have been added, removed, or changed between the two trees. 
Diffing is focused on computing the minimal set of changes needed to update the Virtual DOM.

Reconciliation: Reconciliation is the subsequent step in the process. Once React has identified the differences through diffing, it needs to apply
these changes to the actual, real DOM. Reconciliation is the process of taking the information about the differences identified during diffing and
using it to update the real DOM to match the new Virtual DOM. This process often involves creating, updating, or removing DOM elements or components,
as needed.

In essence, diffing is about comparing the  previous and new Virtual DOM trees and figuring out what's different between them, whereas reconciliation
is about applying those differences to the real DOM. 
----------------------------------------------------------------------

---> JSX 

JSX stands for JavaScript XML.
JSX allows you to write HTML-like code within your JavaScript code, making it easier to define the structure and content of user interfaces.

----------------------------------------------------------------------
---> Components

Components are independent and reusable bits of code.
In React, components are the building blocks of user interfaces. They are reusable, self-contained pieces of code
Function Components (Also known as "Stateless Functional Components")
Class Components (Also known as "Stateful Components"):

----------------------------------------------------------------------
---> Pure Component

A Pure Component is a special type of class component in React that is designed to optimize rendering by reducing unnecessary re-renders.
It does this by automatically performing a shallow comparison of its props and state to determine whether it should update and re-render. 
If the props and state haven't changed, a Pure Component won't re-render, improving performance.

Pure Components are a way to optimize your application's performance by reducing unnecessary re-renders,
 especially when dealing with frequently updated data or props. 

----------------------------------------------------------------------
---> Higher-Order Components

Higher-Order Components are a powerful mechanism for enhancing and reusing the functionality of components in React applications.
HOCs are not components themselves but are functions that take a component as input and return a new component with enhanced functionality. 

import React,{useState} from 'react' 

function HOC(WrappedComponent){
  function Counter(props){
    const [count,setCount] = useState(0)
    const handleAdd = ()=>{
      setCount(count+1)
    }
    return(
      <div>
        <WrappedComponent count={count} handleAdd={handleAdd}/>
      </div>
    )
  }
  return Counter
}

export default HOC;

import React, { useState } from 'react'
import './App.css'
import HOC from './HOC'

function B(props){
  const {count,handleAdd} = props
  return (
    <div className="maindiv">
      <h3>This is B {count}</h3>
      <button onClick={handleAdd}>Add</button>
    </div>
  )
}
export default HOC(B);

import React, { useState } from 'react'
import './App.css'
import HOC from './HOC'
function A(props){
  const {count,handleAdd} = props
   return(
     <div className="maindiv">
       <h3>This is A {count}</h3>
       <button onClick={handleAdd}>Add</button>
      </div>
   )
}
export default HOC(A);
----------------------------------------------------------------------
---> render prop

A "render prop" is a pattern in React where a component takes a function as a prop and calls that function to render some part of its content.
The function, often called the "render prop," is used to provide data or behavior to the component that incorporates it. 

----------------------------------------------------------------------
---> props

in React, "props" is short for "properties," and it refers to a mechanism for passing data from one component to another. Props allow 
you to send data from a parent component to a child component, enabling you to customize and configure the behavior and appearance of components.

----------------------------------------------------------------------
---> Props drilling

Props drilling, also known as "prop drilling" or "component drilling," is a term used in React to describe a situation where data needs
to be passed through multiple layers of components. This can occur when you have a hierarchy of components, and you need to send data
from a top-level component to a deeply nested one.

----------------------------------------------------------------------
---> Conditional rendering

Conditional rendering in React is the process of determining whether or not a component or a part of a component should be displayed
or rendered based on certain conditions or logic. 
Using the if Statement or Conditional (Ternary)
OpeUsing && Logical Operator:rator:

----------------------------------------------------------------------
---> React Router

React Router is a popular library for handling routing and navigation in React applications
with specific URLs. React Router is widely used for building single-page applications (SPAs) and provides a way to navigate
between different views or pages without causing a full page refresh.
<Router>
    <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route path="/contact" component={Contact} />
    </Switch>
</Router>
----------------------------------------------------------------------
---> React.memo

In React, React.memo is a higher-order component (HOC) that is used to optimize the rendering performance of functional components by preventing
unnecessary re-renders. It's similar in concept to PureComponent for class components but is used with functional components. React.memo is part
of the React library and doesn't require any additional installations.
In summary, React.memo is a powerful tool for optimizing the performance of functional components by reducing unnecessary re-renders.
It's especially helpful in scenarios where you want to prevent re-renders when props don't change.

----------------------------------------------------------------------
---> Hooks

React Hooks are a set of functions that allow you to use state and other React features in functional components.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.

----------------------------------------------------------------------
---> State

State generally refers to data or properties that need to be tracking in an application.
State in React holds dynamic data that can change during a component's lifecycle.
data of a specific component.

----------------------------------------------------------------------
--->useState

useState is a React Hook that allows you to add state to functional components. It's used to declare and manage local component state within 
functional components,

----------------------------------------------------------------------
--->useEffect

useEffect is a React Hook that allows you to perform side effects in functional components. Side effects include data fetching,
DOM manipulation, setting up subscriptions, and any other interactions that require interaction with the external world. useEffect
replaces the lifecycle methods that are used in class components to manage side effects.

ComponentDidMount:

useEffect(() => {
    // ComponentDidMount logic here
    console.log('Component has mounted.');
  }, []);

ComponentDidUpdate

 useEffect(() => {
    // componentDidUpdate logic here
    console.log('Component has updated. Count is now: ' + count);
  }, [count]);

ComponentWillUnmount

useEffect(() => {
    // ComponentDidMount logic
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();

    // ComponentWillUnmount cleanup
    return () => {
      console.log('Component is unmounting.');
      // Perform cleanup actions here, such as canceling network requests or clearing timers.
    };
  }, []);

----------------------------------------------------------------------
--->useContext

useContext is a React Hook that allows you to access the value of a context that has been created with React.createContext(). 
Context in React is a way to share data, settings, or configuration information between components without the need to pass 
props explicitly at every level of the component tree.

First, you need to create a context using React.createContext(). This function returns an object with Provider and Consumer components.Wrap the part 
of your component tree where you want to provide a context value with a Provider. The value prop of the Provider sets the value that will be shared 
with components consuming the context.In any functional component that is a descendant of the Provider, you can use the useContext hook to access the context's value.

----------------------------------------------------------------------
--->useRef

useRef is a versatile hook that is often used for tasks such as working with form inputs, managing focus, integrating with third-party 
libraries that require direct DOM manipulation, or storing values that need to persist across renders.
useRef() only returns one item. It returns an Object called current.

Creating a Reference:
You create a reference using the useRef function. This function returns an object that has a .current property.

jsx
Copy code
const myRef = useRef(initialValue);
myRef: This is the reference object.
initialValue: This is the initial value of the reference, which is typically null.
Accessing DOM Elements:
You can attach a ref attribute to a JSX element, allowing you to reference that DOM element using the myRef.current property.

jsx
Copy code
import React, { useRef } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
In this example, we create a reference to the input element with inputRef and use inputRef.current to access and manipulate the DOM element.

----------------------------------------------------------------------
--->useReducer

useReducer is a React Hook that is used for managing complex state logic in a more organized and predictable way, especially when state 
transitions involve multiple actions. It is often used as an alternative to useState when state management becomes more complex. useReducer 
is inspired by the concept of reducers in Redux, a popular state management library.

Here's a detailed explanation of useReducer in a simple way:

Importing the Hook:
First, you need to import useReducer from the react library.

jsx
Copy code
import React, { useReducer } from 'react';
Defining a Reducer Function:
A reducer function is a pure JavaScript function that takes two arguments: the current state and an action. It calculates the new state based on the 
action and returns it.

jsx
Copy code
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}
In this example, the reducer function takes an action object with a type property and performs state updates based on the action type.

Using useReducer:
You call useReducer to initialize your state and specify the reducer function.

jsx
Copy code
const [state, dispatch] = useReducer(reducer, initialState);
state: The current state object.
dispatch: A function that you use to dispatch actions to update the state.
reducer: The reducer function you defined earlier.
initialState: The initial state of the component.
Dispatching Actions:
To update the state, you call the dispatch function and pass an action object as an argument. The reducer function then handles the action and returns the new state.

jsx
Copy code
dispatch({ type: 'INCREMENT' });
dispatch({ type: 'DECREMENT' });
In this example, calling dispatch with an action type of 'INCREMENT' or 'DECREMENT' triggers the state to be updated accordingly.

Using the State:
You can use the state object to access the current state values in your component.

jsx
Copy code
return (
  <div>
    <p>Count: {state.count}</p>
    <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
    <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
  </div>
);
In this example, we display the current count from the state, and the buttons dispatch actions to update it.

----------------------------------------------------------------------
--->useCallback

useCallback is a React Hook used to optimize the performance of your components by memoizing (caching) 
functions so that they are not recreated on every render. It's particularly useful when you need to pass
functions as props to child components, ensuring that these functions do not trigger unnecessary re-renders.

----------------------------------------------------------------------
--->diff bw useMemo and useCallback

useCallback is for memoizing functions, while useMemo is for memoizing any value.
Both hooks take a function as their first argument and an array of dependencies as their second argument.
useCallback is typically used when you want to optimize functions to avoid unnecessary re-renders, especially in the context of passing functions as props.
useMemo is more general and can be used to memoize any value or result, such as the result of a complex calculation or an object that depends on certain values.

----------------------------------------------------------------------
--->diff bw React memo and useMemo

useCallback is for memoizing functions, while useMemo is for memoizing any value.
Both hooks take a function as their first argument and an array of dependencies as their second argument.
useCallback is typically used when you want to optimize functions to avoid unnecessary re-renders, especially in the context of passing functions as props.
useMemo is more general and can be used to memoize any value or result, such as the result of a complex calculation or an object that depends on certain values.

----------------------------------------------------------------------

--->React memo

import React, { useState } from 'react'
import {MemoizedChild} from './Child'
const Parent =()=>{
  const [count,setCount] = useState(0)
  const [name,setName] = useState("jithin")
  const handleCount = () =>{
    setCount(count+1)
  }
  const handleName =()=>{
    setName("Jinto")
  }
  console.log("parent rendering")
  return(
    <div>
      <button onClick={handleCount}>Add count - {count}</button>
      <button onClick = {handleName}>Change name</button>
      <MemoizedChild name={name}/>
    </div>
  )
}
export default Parent


import React from 'react' 

export const Child = (props) =>{
  console.log("child rendering")
  return(
    <div>
      <p>{props.name}</p>
    </div>
  )
}

export const MemoizedChild = React.memo(Child)

----------------------------------------------------------------------
--->Custom Hooks

They enable you to create your own hooks, making it easier to share and reuse code across different components and applications. 
Custom Hooks follow the same rules as built-in React hooks, but you can define your own behavior.
When you have component logic that needs to be used by multiple components, we can extract that logic to a custom Hook.
Custom Hooks start with "use". Example: useFetch.

import React,{useState} from 'react' 

const UserCounter = () =>{
  const [count,setCount] = useState(0)
  const handleDec=()=>{
    setCount(count-1)
 }
 const handleInc=()=>{
   setCount(count+1)
 }
  return {count,handleDec,handleInc}
}


export default UserCounter;
import React, { useState } from 'react'
import UserCounter from './UserCounter'
function Counter(){
  const {count,handleDec,handleInc} = UserCounter() 
  return(
    <div>
      <p>Count - {count}</p>
      <button onClick={handleInc}>Increment</button>
      <button onClick={handleDec}>decrement</button>
    </div>
  )
}
export default Counter 

----------------------------------------------------------------------
--->Context API vs Redux

Context API and Redux are both state management solutions for React applications, 

With Redux, the entire state of your application is stored in a single place, making it easily accessible to any 
component without the need to pass props around. It operates based on three core concepts:

Actions
Reducers
Store
Actions represent events that send data to the Redux store. They can be triggered by user interactions or called directly by your 
application. Each action has a unique type and a payload associated with it.
----------------------------------------------------------------------
--->state vs props

Local to the Component: State is an internal data storage mechanism that is specific to a particular component. It is maintained within the component 
itself and is not accessible to other components.

Mutable: State is mutable and can be modified within the component by calling this.setState(). When the state is updated, React will re-render the 
component to reflect the changes.
----------------------------------------------------------------------
--->diff b/w useMemo and React.memo


useMemo: It is a hook used for memoizing the result of a function or a computation. It allows you to optimize the performance 
of your component by caching the result of a function and recalculating it only when the dependencies change.

React.memo: It is a higher-order component used to optimize functional components by preventing unnecessary re-renders. It memoizes 
the rendering output of a component and only re-renders when the component's props change.

----------------------------------------------------------------------


Certainly! In a simpler way, a cleanup function in React is like tidying up after yourself when you're done with something. It's a 
piece of code that you write to clean up resources or cancel tasks when a part of your web page (a component) is no longer needed

----------------------------------------------------------------------

div. Fragments allow you to avoid adding unnecessary elements to the DOM structure.

----------------------------------------------------------------------

Controlled components and uncontrolled components are two approaches to managing form elements (like input fields, checkboxes, and radio buttons) 
in a React application.
In a controlled component, React controls the form element's value by maintaining it in the component's state. You handle changes by defining 
event handlers and updating the state. 
In an uncontrolled component, you let the HTML element maintain its state. You don't control the form element's value with React state. Instead, 
you directly access the element's value through references or DOM manipulation when needed.

----------------------------------------------------------------------


The React Profiler is a tool that is part of React's developer tools suite. It is designed to help you analyze and optimize 
the performance of your React applications. Profiling your application can be essential to ensure that it runs smoothly, especially 
in large and complex applications. 

----------------------------------------------------------------------

Lazy loading in React is a technique used to improve the performance of your web application. It allows you to load certain parts of your 
application only when they are actually needed, rather than loading everything when the page first loads. This can make your app faster and 
more efficient because it reduces the initial load time.

----------------------------------------------------------------------

It takes all of the individual JavaScript files and other assets in a project, such as images and CSS, and combines them into a single 
bundle that can be loaded by the browser. Webpack also has the ability to transpile modern JavaScript code (such as ES6) into older 
versions that can be understood by older browsers.

----------------------------------------------------------------------
--->PropTypes

PropTypes provide a level of type checking for the props passed to a React component. They help ensure that the props conform to the expected data types. 
import PropTypes from 'prop-types';

MyComponent.propTypes = {
  stringProp: PropTypes.string,
  numberProp: PropTypes.number,
  boolProp: PropTypes.bool,
  arrayProp: PropTypes.array,
  objectProp: PropTypes.object,
  functionProp: PropTypes.func,
};


PropTypes in React functional components are used to specify the expected data types and, optionally, additional validation rules for the props that a component should receive. They help catch errors and ensure that the component is used correctly. Here's how to use PropTypes in a functional component with an example:

First, make sure to import PropTypes from the prop-types library:

javascript
Copy code
import PropTypes from 'prop-types';
Let's create a simple functional component and define PropTypes for its props:

javascript
Copy code
import React from 'react';
import PropTypes from 'prop-types';

function Greeting(props) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>You are {props.age} years old.</p>
    </div>
  );
}

Greeting.propTypes = {
  name: PropTypes.string.isRequired, // name should be a required string
  age: PropTypes.number, // age should be a number (optional)
};

export default Greeting;

----------------------------------------------------------------------

Axios provides a convenient way to cancel HTTP requests using cancel tokens. This can be helpful when you need to cancel ongoing requests, 
especially in scenarios like user-initiated actions or when navigating away from a page. To use Axios cancel tokens, you'll need to create a 
cancel token and attach it to your request.

Here's how to use Axios cancel tokens:

Import Axios:

First, make sure to import Axios if you haven't already:

javascript
Copy code
import axios from 'axios';
Create a Cancel Token:

You can create a cancel token using the axios.CancelToken.source factory method:

javascript
Copy code
const { token, cancel } = axios.CancelToken.source();
The token is the cancel token itself, and cancel is a function to cancel the request.

Attach Cancel Token to the Request:

When making an Axios request, you can attach the cancel token to the cancelToken option in the request configuration:

javascript
Copy code
axios.get('/your/api/endpoint', {
  cancelToken: token,
})
  .then(response => {
    // Handle the successful response
  })
  .catch(error => {
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
    } else {
      // Handle other errors
    }
  });
Cancel the Request:

To cancel the request, you can call the cancel function. This can be triggered, for example, when a user navigates away from 
the page or performs a specific action:

cancel('Request canceled by the user');
When the request is canceled, the promise will reject with an error object that you can handle in the catch block. You can check 
if the error is a cancel error using axios.isCancel(error).

Here's a complete example of using Axios cancel tokens:

javascript
Copy code
import axios from 'axios';

function makeRequest() {
  const { token, cancel } = axios.CancelToken.source();

  axios.get('/your/api/endpoint', {
    cancelToken: token,
  })
    .then(response => {
      // Handle the successful response
      console.log('Response:', response.data);
    })
    .catch(error => {
      if (axios.isCancel(error)) {
        console.log('Request canceled:', error.message);
      } else {
        console.error('Request failed:', error);
      }
    });

  // Simulate cancelling the request (e.g., user action)
  setTimeout(() => {
    cancel('Request canceled by the user');
  }, 1000);
}

makeRequest();
In this example, we create a request, set a timeout to cancel it after 1 second, and handle both the successful response 
and the canceled request using Axios cancel tokens.


----------------------------------------------------------------------
