
----------------------------------------------------------------------

React is a JavaScript library for building user interfaces.

React is used to build single-page applications.

React allows us to create reusable UI components.

----------------------------------------------------------------------

---> How does React Work?

React creates a VIRTUAL DOM in memory.

Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, 
before making the changes in the browser DOM.

React only changes what needs to be changed!
----------------------------------------------------------------------
---> DOM

In JavaScript, the Document Object Model (DOM) is a programming interface that represents the structure of a web page and
 allows you to interact with and manipulate the content and elements of that page.
. It provides a structured representation of a web page, where each HTML element, attribute, and piece of content is represented as an object.
Think of the DOM as a tree structure, where the entire web page is represented as a tree of nodes. The top node, or the root, is called the document object.
HTML elements, such as headings (<h1>), paragraphs (<p>), and images (<img>), are represented as nodes in the DOM tree. Each node can have child nodes,
 which represent elements contained within it.

----------------------------------------------------------------------

---> Virtual Dom

in React, the Virtual DOM (short for "Virtual Document Object Model") is a key concept that helps improve the performance and 
efficiency of rendering updates in web applications. It's a virtual representation of the actual DOM in memory, and it plays a
crucial role in React's ability to efficiently update the user interface.

When you make changes to a React component (e.g., updating the state or props), React doesn't immediately make changes to the real DOM.
Instead, it updates the Virtual DOM.

Initial Render:

When you initially load a React application or component, React creates a Virtual DOM representation of the entire component hierarchy. 
This Virtual DOM is a lightweight, in-memory JavaScript representation of the actual DOM.
Component Updates:

When you interact with a React component, such as changing its state or passing new props, React needs to update the user interface to reflect these changes.
Creating a New Virtual DOM:

When a change occurs, React creates a new Virtual DOM tree to represent how the component should look after the change. 
This new Virtual DOM tree reflects the updated state or props.
Diffing and Reconciliation:

React employs a process called "reconciliation" to compare the new Virtual DOM with the previous Virtual DOM. 
It identifies the differences (or "diffs") between the two Virtual DOM trees.
Determining Minimal Updates:

The diffing process determines the minimal set of changes needed to bring the new Virtual DOM in line with
 the updated state. It calculates what elements have been added, changed, or removed.
Batching Updates:

React batches multiple updates together for efficiency. Instead of immediately updating the real DOM with every change, 
it queues these updates, allowing React to optimize the rendering process.
Updating the Real DOM:

Once the differences are identified, React applies the necessary changes to the real DOM. It directly updates the browser's
DOM only with the specific changes required to reflect the new Virtual DOM.

----------------------------------------------------------------------

---> Diff b/w diffing and reconcilation

Diffing: This is the process of comparing the new Virtual DOM tree (generated after a component update) with the previous Virtual DOM tree
(representing the component's previous state). The goal of diffing is to identify the differences between these two Virtual DOM trees efficiently.
Specifically, React's diffing algorithm aims to find which elements or components have been added, removed, or changed between the two trees. 
Diffing is focused on computing the minimal set of changes needed to update the Virtual DOM.

Reconciliation: Reconciliation is the subsequent step in the process. Once React has identified the differences through diffing, it needs to apply
these changes to the actual, real DOM. Reconciliation is the process of taking the information about the differences identified during diffing and
using it to update the real DOM to match the new Virtual DOM. This process often involves creating, updating, or removing DOM elements or components,
as needed.

In essence, diffing is about comparing the previous and new Virtual DOM trees and figuring out what's different between them, whereas reconciliation
is about applying those differences to the real DOM. 
----------------------------------------------------------------------

---> JSX 

JSX stands for JavaScript XML.
JSX allows you to write HTML-like code within your JavaScript code, making it easier to define the structure and content of user interfaces.

----------------------------------------------------------------------
---> Components

Components are independent and reusable bits of code.
In React, components are the building blocks of user interfaces. They are reusable, self-contained pieces of code
Function Components (Also known as "Stateless Functional Components")
Class Components (Also known as "Stateful Components"):

----------------------------------------------------------------------
---> Pure Component

A Pure Component is a special type of class component in React that is designed to optimize rendering by reducing unnecessary re-renders.
It does this by automatically performing a shallow comparison of its props and state to determine whether it should update and re-render. 
If the props and state haven't changed, a Pure Component won't re-render, improving performance.

Pure Components are a way to optimize your application's performance by reducing unnecessary re-renders,
 especially when dealing with frequently updated data or props. 

----------------------------------------------------------------------
---> Higher-Order Components

Higher-Order Components are a powerful mechanism for enhancing and reusing the functionality of components in React applications.
HOCs are not components themselves but are functions that take a component as input and return a new component with enhanced functionality. 

----------------------------------------------------------------------
---> render prop

A "render prop" is a pattern in React where a component takes a function as a prop and calls that function to render some part of its content.
The function, often called the "render prop," is used to provide data or behavior to the component that incorporates it. 

----------------------------------------------------------------------
---> props

in React, "props" is short for "properties," and it refers to a mechanism for passing data from one component to another. Props allow 
you to send data from a parent component to a child component, enabling you to customize and configure the behavior and appearance of components.

----------------------------------------------------------------------
---> Props drilling

Props drilling, also known as "prop drilling" or "component drilling," is a term used in React to describe a situation where data needs
to be passed through multiple layers of components. This can occur when you have a hierarchy of components, and you need to send data
from a top-level component to a deeply nested one.

----------------------------------------------------------------------
---> Conditional rendering

Conditional rendering in React is the process of determining whether or not a component or a part of a component should be displayed
or rendered based on certain conditions or logic. 
Using the if Statement or Conditional (Ternary)
OpeUsing && Logical Operator:rator:

----------------------------------------------------------------------
---> React Router

React Router is a popular library for handling routing and navigation in React applications
with specific URLs. React Router is widely used for building single-page applications (SPAs) and provides a way to navigate
between different views or pages without causing a full page refresh.
<Router>
    <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route path="/contact" component={Contact} />
    </Switch>
</Router>
----------------------------------------------------------------------
---> React.memo

In React, React.memo is a higher-order component (HOC) that is used to optimize the rendering performance of functional components by preventing
unnecessary re-renders. It's similar in concept to PureComponent for class components but is used with functional components. React.memo is part
of the React library and doesn't require any additional installations.
In summary, React.memo is a powerful tool for optimizing the performance of functional components by reducing unnecessary re-renders.
It's especially helpful in scenarios where you want to prevent re-renders when props don't change.

----------------------------------------------------------------------
---> Hooks

React Hooks are a set of functions that allow you to use state and other React features in functional components.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.

----------------------------------------------------------------------
---> State

State generally refers to data or properties that need to be tracking in an application.
State in React holds dynamic data that can change during a component's lifecycle.
data of a specific component.

----------------------------------------------------------------------
--->useState

useState is a React Hook that allows you to add state to functional components. It's used to declare and manage local component state within functional components,

----------------------------------------------------------------------
--->useEffect

useEffect is a React Hook that allows you to perform side effects in functional components. Side effects include data fetching,
DOM manipulation, setting up subscriptions, and any other interactions that require interaction with the external world. useEffect
replaces the lifecycle methods that are used in class components to manage side effects.

ComponentDidMount:

useEffect(() => {
    // ComponentDidMount logic here
    console.log('Component has mounted.');
  }, []);

ComponentDidUpdate

 useEffect(() => {
    // componentDidUpdate logic here
    console.log('Component has updated. Count is now: ' + count);
  }, [count]);

ComponentWillUnmount

useEffect(() => {
    // ComponentDidMount logic
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();

    // ComponentWillUnmount cleanup
    return () => {
      console.log('Component is unmounting.');
      // Perform cleanup actions here, such as canceling network requests or clearing timers.
    };
  }, []);

----------------------------------------------------------------------
--->useContext

useContext is a React Hook that allows you to access the value of a context that has been created with React.createContext(). 
Context in React is a way to share data, settings, or configuration information between components without the need to pass 
props explicitly at every level of the component tree.

First, you need to create a context using React.createContext(). This function returns an object with Provider and Consumer components.Wrap the part 
of your component tree where you want to provide a context value with a Provider. The value prop of the Provider sets the value that will be shared 
with components consuming the context.In any functional component that is a descendant of the Provider, you can use the useContext hook to access the context's value.

----------------------------------------------------------------------
--->useRef

useRef is a versatile hook that is often used for tasks such as working with form inputs, managing focus, integrating with third-party 
libraries that require direct DOM manipulation, or storing values that need to persist across renders.
useRef() only returns one item. It returns an Object called current.

Creating a Reference:
You create a reference using the useRef function. This function returns an object that has a .current property.

jsx
Copy code
const myRef = useRef(initialValue);
myRef: This is the reference object.
initialValue: This is the initial value of the reference, which is typically null.
Accessing DOM Elements:
You can attach a ref attribute to a JSX element, allowing you to reference that DOM element using the myRef.current property.

jsx
Copy code
import React, { useRef } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
In this example, we create a reference to the input element with inputRef and use inputRef.current to access and manipulate the DOM element.

----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
----------------------------------------------------------------------
--->
